c (c) copyright 1999,2000,2004,2005,2006 David G. Long, Brigham Young University
	program	ssmi_meta_make
c
c	generate SSM/I SIR/SIRF metafile
c
c	Written: D. Long     9 Jan. 1999
c        +modified from sea_meta_make6
c       Modified: D. Long   28 Mar. 2000
c        +a/d file names, dateline
c       Modified: D. Long   28 Mar. 2000
c        +improved production scripting
c       Modified: Shuyi Li  28 May. 2002
c        +fix the ascending_descending Bug
c       Modified: D. Long   28 Mar. 2004 + modified to compile under LF95
c       Modified: D. Long   28 Jul. 2005 + include sir2gif step for 'a' images
c       Modified: D. Long   13 Sep. 2005 + fixed and modified EASE projection case
c       Modified: D. Long   16 Dec. 2006 + added local-time-of-day and .s2g file pass in
c
	implicit none
c
	integer       argc,argn
       	character*180 fname,jname,line,S2G
c
	integer       id,idj
	character*40  program
	character*10  program_version
	character     datestr*9, timestr*8
c
	integer       length,iargc,F_num
c
	data program/'ssmi_meta_make'/
	data program_version/'V3.0'/
c
c	begin program
c
	write (*,*) 'SSM/I Metafile Maker'
	write (*,*) program,' Version: ',program_version
	write (*,*)
c
c       get date and time of program run
c
c$nostandard system on      ! HP compiller directive to enable date/time
	call date(datestr) ! date call
	call time(timestr)
c$nostandard system off
	write (*,*) 'Date and time of program run: "',datestr,'"  "',timestr,'"'
c
	argc = iargc()		! number of command line arguments
	argn = 1		! command line argument counter
c
 	if (argc.lt.argn+1) then
         write (*,*) '*** Inputs may be entered at the command line.'
        endif
c
c       get output file name
c
	write (*,*)
	if (argc.lt.argn) then
	  write (*,1) 'Output file name:'
1	  format(1x,a,1x,$)
	  read (*,'(a80)') fname
	else
	  call getarg(argn,fname)
	  argn = argn + 1
	endif
	if (argc.lt.argn) then
	  write (*,1) 'Satellite number (e.g. 13 for F13) '
	  read (*,'(I2)') F_num
	else
	  call getarg(argn,line)
	  read(line,'(I2)') F_num
	  argn = argn + 1
	endif
c
c       open output meta file and write header
c
	id=3
	write (*,*) 'Opening output file "',fname(1:length(fname)),'"'
	open(unit=id,file=fname,status='new',form='formatted')
c
	write (id,'(''File='',a)') fname(1:length(fname))
	write (id,'(''Generated by='',a)') program(1:length(program))
	write (id,'(''Version='',a)') program_version(1:length(program_version))
	write (id,'(''Meta_file_date='',a)') datestr
	write (id,'(''Sensor='',a,I2)') 'SSM/I F',F_num
c
c       open output job file and write header
c
	jname=fname(1:length(fname))//'.job'
	idj=4
	write (*,*) 'Opening job file "',jname(1:length(jname)),'"'
	open(unit=idj,file=jname,status='unknown',form='formatted')
	write (idj,'(''#!/bin/sh'')')
	write (idj,'(''# Job File='',a)')       jname(1:length(jname))
	write (idj,'(''# Generated by='',a)')   program(1:length(program))
	write (idj,'(''# Version='',a)') program_version(1:length(program_version))
	write (idj,'(''# Meta_file_date='',a)') datestr
	write (idj,'(''# Meta_file='',a)')      fname(1:length(fname))
c
c       get S2G argument
c
	S2G='ssmi.s2g'
	if (argc.lt.argn) then
	   write (*,110)
 110	   format(1x,'Enter .s2g command (NONE=blank)',$)
	   read(*,'(a120)') S2G
	else
	   call getarg(argn,S2G)
	   argn = argn + 1
	endif
	if (S2G.eq.'NONE') S2G=' '
c
c       get input region parameters and write to file
c
        call get_region_parms(id,argc,argn,idj,fname,F_num,S2G)
c
c       get list of Quikscat input data file names and save to file
c
	call get_file_names(id,argc,argn)
c
c       close output file
c
	close(id)
	close(idj)
	write(*,*) 'Finished writing meta file "',fname(1:length(fname)),'"'
	write(*,*) 'Finished writing job file  "',jname(1:length(jname)),'"'
	write(*,*)
	write(*,*) 'Job command: nice ',jname(1:length(jname)),' > ',jname(1:length(jname)),'.out 2>&1'
c
c       make job file executable
c
	fname='chmod 755 '//jname(1:length(jname))
	fname(length(fname)+1:length(fname)+1)=char(0)
	call system(fname)
c
	stop
	end	
c
c ***************************************************************************
c
	subroutine getregdata(regnum,iproj,dateline,latl,lonl,lath,lonh,regname,rname)
	integer*4     regnum
	logical       dateline
	real*4        latl,lath,lonl,lonh
	character*(*) regname
	character*(*) rname
c
c	reads region definition file to get the
c	region name and corners from the region number
c
	integer      regnum1,idateline
	character*68 header1,header2
	integer*4    ios
c
	dateline=.false.
	open(unit=15,file=rname,status='old',err=200,iostat=ios,
     *       form='formatted')
c
	read(15,'(a68)',err=200,iostat=ios) header1
	read(15,'(a68)',err=200,iostat=ios) header2
c
 10	format(I4,2x,I2,1x,I2,1x,F6.1,6x,F8.1,3x,F8.1,4x,F8.1,4x,A10)
c
 110	read(15,10,err=200,iostat=ios) regnum1,iproj,idateline,latl,lonl,
     *                                 lath,lonh,regname
c	write(*,10) regnum1,iproj,latl,lonl,lath,lonh,regname
c
	if (regnum1.eq.9999) then  ! reached last entry of file
	   write (*,*) 'Region ',regnum,' not found in ',rname
	   close(15)
	   stop
	endif
	if (regnum1.ne.regnum) goto 110
	write(*,10) regnum1,idateline,iproj,latl,lonl,lath,lonh,regname
	if (idateline.eq.1) dateline=.true.
	close (15)
	return
c
 200	continue
	write (*,*) '*** error reading file ',rname
	write (*,*) '*** error # ',ios,' region',regnum
	close(15)
	stop
	end
c
c ***************************************************************************
c
        subroutine get_region_parms(id,argc,argn,idj,fname,F_num,S2G)
c
c      define regions and write to file
c
	implicit none
c
	integer     id,argc,argn,idj,F_num
	character*(*) fname,S2G
c
	character*200 fnamel,sirf_name
	integer	    toil,iasc,ircnt
	real        lath,latl,lonh,lonl
	integer     poleflag
	integer     mstart,mend,projt,iproj
	real        rmostx,lmostx,umosty,lmosty
	real  	    mapuylat,mapuylon,maplylat,maplylon,
     *                maprxlat,maprxlon,maplxlat,maplxlon
	real        aorglat,aorglon
	integer     nsx,nsy
	real	    ascale,bscale,a0,b0,xdeg,ydeg
	real        ascale2,bscale2,a02,b02,xdeg2,ydeg2
	real	    ascale_s,bscale_s,a0_s,b0_s,xdeg_s,ydeg_s
	integer     nsx2,nsy2,non_size,nsx_s,nsy_s
	real	    trans,x0,y0
	integer     xdim,ydim
	integer     nregions,iregion,ipolar,negg,ibeam
        integer     nsection,isection,nt,nsect,ix,iy
	integer     ix1,iy1,ix2,iy2,jx1,jy1,jx2,jy2
	integer     ix1g,iy1g,ix2g,iy2g,jx1g,jy1g,jx2g,jy2g
	real        deglat,deglon,maplxon,maprxon,temp
	integer     dstart,dend,year
	character   cpol*1, cegg*2, reg*3
	character*120 a_name,b_name,i_name,j_name,c_name,p_name,
	1    v_name,e_name,lisname,aa_name,bb_name,non_aname,non_bname,
	2    non_vname,grd_aname,grd_bname,grd_vname,grd_iname,grd_jname,
	3    grd_pname,grd_cname,setname
	character*120 name_store(30),name_store2(30)
c
c variables for command-line entry
c
	character*5   dstartch,dendch,yearch,neasech
	character*5   regnumch
	character*7   latlch,lathch,lonlch,lonhch,toilch,deglatch
	character*1   yn
c	character*2   projtch
	logical       dateline
	integer       idateline
c
c variables for region file reading
c
	integer       regnum
	character*10  regname
	character*120 rname,rfile
	logical       pfile,sections
c
c variables for EASE projection
c
	integer       nease
c
c       character string length function
c
	integer length
	integer nits
	real    response_threshold,a_init,a_offset,b_init,b_weight,angle_ref
	logical median_flag, flatten
	real tsplit1,tsplit2
c
c ******************************************************************
c
c       define region definition file
c
	rname = '/auto/share/ref/regiondef1.dat'   ! file defining region codes
c	rname = '/auto/cers0/long/sir/regiondef1.dat'   ! file defining region codes
c	rname = '/vol2/m2/long/sir/regiondef1.dat'   ! file defining region codes
c
c       Eggs or Slices
c
c	if (argc.lt.argn) then
c	   write (*,1) ' Egg (0) or Slices (1): '
c	   read (*,*) negg
c	else
c	   call getarg(argn, eggch)
c	   argn = argn + 1
c	   read(eggch,'(i2)') negg
c	endif
	negg=2
c
c  general SIR/SIRF slice/egg coding scheme
c
c                  Response Funct    A/ 
c       negg     Egg1  Slice1  Egg2  A+B  Other   Sensor
c        0        0                   0     0      Seawinds/QuikScat egg
c        1               1            0     0      Seawinds/QuikScat slice
c       101              1           100    0      NSCAT
c       101              1           100    0      SASS
c       102                    2     100    0      ERS-1
c        2                     2      0     0      SSM/I, SMMR, AMSRE
c       100       0                  100    0      TRMM
c
	write (id,'(''Egg_or_slice='',I1)') negg
c
c       write out setup file command to job file
c
	write (idj,'('' echo "Running setup on '',a,''"'')') fname(1:length(fname))
	fnamel=fname(1:length(fname))//'.out'
	sirf_name='ssmi_meta_sir'
	write(idj,'(''if ssmi_meta_setup '',a,'' > '',a)') fname(1:length(fname)),fnamel(1:length(fnamel))
	write(idj,'(''then '')') 
	write(idj,'('' echo "setup successfully completed"'')') 
	write(idj,'('' SIRFsOK=0 '')') 
	sections=.false.
c
c       read time period information
c
	if (argc.lt.argn+2) then
	   write (*,1) 'Starting day #:'
 1	   format(1x,a,' ==>',$)
	   read(*,*) dstart
	   write (*,1) 'Ending day #:'
	   read(*,*) dend
	   write (*,1) 'Starting year (xxxx): '
	   read(*,*) year
	else
	   call getarg(argn,dstartch) !read run-line arguments (string)
	   argn = argn + 1	!run-line argument index
	   call getarg(argn,dendch)
	   argn = argn + 1
	   call getarg(argn,yearch)
	   argn = argn + 1
	   read (dstartch,'(i3)') dstart
	   read (dendch,'(i3)') dend
	   read (yearch,'(i4)') year
	endif
	mstart = 0	! start minute and end minute
	mend = 1440	! but are placed in output file header)
!!	mend = 2500	!! modified DGL to match AMSR
c      
	write (*,*) 'Day range: ',dstart,dend,' Year:',year
c
	write(id,'(''Begin_description'')') 
	write(id,'('' Start_Year='',I5)') year
	write(id,'('' Start_day='',I4)') dstart
	write(id,'('' End_day='',I4)') dend
	write(id,'('' Start_minute='',I4)') mstart
	write(id,'('' End_minute='',I4)') mend
c
c       SIRF imaging options
c
	a_init=200.0
	a_offset=0.0
	b_init=0.0
	b_weight=1
	nits=20
c	if (negg.eq.1) nits=50
	angle_ref=00.0
	response_threshold=-8.0
	flatten=.false.
	median_flag=.false.
c	if (negg.eq.1) median_flag=.true.
c
	write(id,'('' A_initialization='',F10.5)') a_init
	write(id,'('' A_offset_value='',F10.5)') a_offset
	write(id,'('' B_initialization='',F10.5)') b_init
	write(id,'('' B_weight='',F10.5)') b_weight
	write(id,'('' Max_iterations='',I3)') nits
	write(id,'('' Reference_incidence_angle='',F10.5)') angle_ref
	write(id,'('' Response_threshold='',F10.5)') response_threshold
	write(id,'('' Flat_response='',L1)') flatten
	write(id,'('' Median_filter='',L1)') median_flag
c
	if (argc.lt.argn) then
	   write (*,209)
 209	   format(1x,'Enter region parameters file name: (NONE for manual input) ',$)
	   read(*,'(a120)') rfile
	   if (.not.(rfile.ne.' ')) rfile='NONE'
	else
	   call getarg(argn,rfile)
	   argn = argn + 1
	endif
c
	if (rfile(1:4).eq.'NONE'.or.rfile(1:1).eq.'N'.or.
	1    rfile(1:4).eq.'none'.or.rfile(1:1).eq.'n') then
	   pfile=.false.
	else
	   pfile=.true.
	   open(unit=2,file=rfile,form='formatted',status='old')
	   write(id,'('' Region_parameters_file='',A)') rfile(1:length(rfile))
	endif
c
	if (pfile) then
	   read(2,*) nregions
	   write(*,'('' Number of regions'',i2)') nregions
	else
	   if (argc.lt.argn) then
	      write (*,111)
 111	      format(1x,'How many regions to output?  ',$)
	      read(*,*) nregions
	   else
	      call getarg(argn,yearch)
	      argn = argn + 1
	      read (yearch,'(i2)') nregions
	      write(*,'('' Number of regions'',i2)') nregions
	   endif
	endif
c
	write(id,'('' Num_Regions='',i2)') nregions
c
c	for each region, read in region definition and other selection criteria
c
	ircnt=0
	do iregion=1,nregions
	   dateline=.false.
c
 34	   format(' ==>',$)
c
c       get region ID number
c
	   if (pfile) then
	      read (2,*) regnum
	      write (*,'(/'' Region '',I2,'' of '',I2,'': Id='',i4)') iregion,nregions,regnum
	   else
	      if (argc.lt.argn) then
		 write (*,*)
		 write (*,*) 'Region definition input for Region ',iregion,' of ',nregions
		 write (*,*) 'Enter region ID number to extract (or a negative',
	1	      '    value to describe it explicitly)'
		 write (*,34)
		 read(*,'(i4)') regnum
	      else
		 call getarg(argn,regnumch)
		 read (regnumch,'(i4)') regnum
		 argn=argn+1
	      endif
	   endif
c
c       use automatic region ID definition file if possible
c
	   regname='Custom'
	   if (regnum.ge.0) then ! read region description from region.data
	      call getregdata(regnum,iproj,dateline,latl,lonl,lath,lonh,regname,rname)
	      If ((regnum.ge.100).and.(regnum.lt.110)) poleflag=2 !south pole
	      if ((regnum.ge.110).and.(regnum.lt.120)) poleflag=1 !north pole
	      if (((regnum.ge.0).and.(regnum.lt.100)).or.
	1	   (regnum.ge.120)) poleflag=0 ! other area
	      write (*,*) 'Region name:  ',regname,'  Def Proj ',iproj,' Dateline ',dateline
	      goto 300
	   endif
c
c explicit entry of region definition information
c
	   if (argc.lt.argn) then
	      write (*,1) 'Is this a polar region? (Y/N)'
	      read (*,'(a1)') yn
	   else
	      call getarg(argn,yn)
	      argn = argn + 1
	   endif
	   if ((yn.eq.'Y').or.(yn.eq.'y')) then
	      write (*,*) 'Polar region:'
	      if (argc.lt.argn) then
		 write (*,1) '       Degrees in latitude?'
		 read(*,*) deglat
	      else
		 call getarg(argn,deglatch)
		 argn = argn + 1
		 read(deglatch,'(i4)') deglat
	      endif
	      if (argc.lt.argn) then
		 write (*,1) '       North pole? (Y/N)'
		 read (*,'(a1)') yn
	      else
		 call getarg(argn,yn)
		 argn = argn + 1
	      endif
	      if ((yn.eq.'Y').or.(yn.eq.'y')) then
		 lath = 90.	! NORTH POLE
		 latl = 90. - deglat
		 lonh = 180.
		 lonl = -180.
		 poleflag = 1
	      else
		 latl = -90.	! SOUTH POLE
		 lath = -90. + deglat
		 lonl = -180.
		 lonh = 180
		 poleflag = 2
	      endif
	   else
	      write (*,*) 'Specify coordinates: (-180 to 180 lon, -90 to 90 lat)'
	      poleflag = 0
	      idateline = 0
	      if (argc.lt.argn+3) then
		 write (*,*) 'Enter coordinates for lower left-hand corner:'
		 write (*,1) '       Latitude:'
		 read(*,*) latl
		 write (*,1) '       Longitude:'
		 read(*,*) lonl
		 write (*,*) 'Enter coordinates for upper right-hand corner:'
		 write (*,1) '       Latitude:'
		 read(*,*) lath
		 write (*,1) '       Longitude:'
		 read(*,*) lonh
		 write (*,*) 'Enter 1 if region cross dateline, otherwise enter 0:'
		 read(*,*) idateline
	      else
		 call getarg(argn,latlch)
		 call getarg(argn+1,lonlch)
		 call getarg(argn+2,lathch)
		 call getarg(argn+3,lonhch)
		 argn = argn + 4
		 read(latlch,'(f6.1)') latl
		 read(lonlch,'(f6.1)') lonl
		 read(lathch,'(f6.1)') lath
		 read(lonhch,'(f6.1)') lonh
		 call getarg(argn,lonhch)
		 argn = argn + 1
		 read(lonhch,'(i1)') idateline
	      endif
	      if (idateline.eq.1) dateline=.true.
	      deglat = lath - latl
	      deglon = lonh - lonl
	   endif

 300	   continue
c
c       region ID number and bounding box defined
c
	   write (*,*)
	   write (*,*) 'Region definition information:'
	   write (*,*) '   Latitude range: ',latl,lath
	   write (*,*) '   Longituge range: ',lonl,lonh
	   write (*,*) '   Region code (0=arbitrary,1=N.pole,2=S.pole)',poleflag
c
	   if (dateline) then
	      write (*,*) 'Crosses Dateline'
	      lonh=mod(lonh+720.,360.)
	      lonl=mod(lonl+720.,360.)
	      maplxon=min(lonh,lonl)
	      maprxon=max(lonh,lonl)
	      lonl=maplxon
	      lonh=maprxon
	      write (*,*) '   Corrected longituge range: ',lonl,lonh
	   endif
c
c       write to output file
c
	   write(id,'('' Begin_region_description'')')
	   write(id,'(''  Region_id='',I4)') regnum
	   write(id,'(''  Latitude_low='',F16.9)') latl
	   write(id,'(''  Latitude_high='',F16.9)') lath
	   write(id,'(''  Longitude_low='',F16.9)') lonl
	   write(id,'(''  Longitude_high='',F16.9)') lonh
	   write(id,'(''  Dateline_crossing='',L1)') dateline
	   write(id,'(''  Polar_flag='',I1)') poleflag
	   write(id,'(''  Region_name='',a)') regname
c
c*******************************************************
c	tranformation information
c*******************************************************
c
c       select projection
c
	   projt=iproj  ! default value from region definition file
c
c	   if (argc.lt.argn) then
c	      write (*,*) 'Projection codes: ',iproj
c	      write (*,*) '   0 = Rectalinear lat/lon'
c	      write (*,*) '   1 = Lambertian Equal-Area (fixed radius)'
c	      write (*,*) '   2 = Lambertian Equal-Area (local radius)'
c	      write (*,*) '   5 = SAR Polar Stereographic'
c	      write (*,*) '  11 = EASE north'
c	      write (*,*) '  12 = EASE south'
c	      write (*,*) '  13 = EASE globe'
c	      write (*,1) 'Enter projection code:  '
c	      read (*,*) projt
c	   else
c	      call getarg(argn, projtch)
c	      argn = argn + 1
c	      read(projtch,'(i1)') projt
c	   endif
c
	   write (*,*) 'Projection code (0=lat/lon,1=Lambert(fixed),2=Lambert(local)',
	1	'                 5=Polar stereo,11-13=EASE):  ',projt
c
c       for each projection define origin, size, scale, and offset
c
	   if (projt.eq.0) then	! rectangular lat/lon
	      a0=lonl
	      b0=latl
	      aorglon=lonh-lonl
	      aorglat=lath-latl
	      ascale=24.0	! pixels/deg (SASS/NSCAT/Seawinds eggs)
c	      if (negg.eq.1) ascale=48.0 ! pixels/deg (SeaWinds slices)
	      bscale=ascale
	      write (*,*) 'Lat/Lon grid pixel spacing: ',ascale,bscale,' pixels/deg'
	      xdeg=aorglon
	      ydeg=aorglat
	      nsx=xdeg*ascale
	      nsy=ydeg*bscale
	      write (*,*) 'Corner:',a0,b0,' deg'
	      write (*,*) 'Span:  ',xdeg,ydeg
	   else if ((projt.eq.1).or.(projt.eq.2)) then ! lambertian equal-area
	      trans = 0.
c              ascale = 1./8.9    ! 8.9 km/pixel (ers-1)
	      ascale = 2./(8.9)	! 4.45 km/pixel (SASS/NSCAT/Seawinds eggs)
	      if (negg.eq.1) ascale = 4./(8.9)	! 2.225 km/pixel (Seawinds slices)
	      bscale = ascale
c
	      write (*,*) 'Lambert pixel spacing:',1./ascale,1./bscale,' km/pixel'
c
c figure out what kind of area (polar or otherwise) and set up origin 
c   and mapping transformation variables for lambertian
c
	      if (poleflag.eq.0) then ! not a polar region, origin in center
		 aorglat = (lath + latl)/2.
		 aorglon = (lonh + lonl)/2.
		 mapuylat = lath
		 maplylat = latl
		 maplxlon = lonl
		 maprxlon = lonh
		 if (lath*latl.lt.0) then ! region contains equator
		    maplxlat = 0.
		    maprxlat = 0.
		    if (lath.gt.abs(latl)) then	! mostly in nrthrn hemisph
		       mapuylon = lonl
		       maplylon = aorglon
		    else	! mostly in sthrn hemisph
		       mapuylon = aorglon
		       maplylon = lonl
		    endif
		 else 
		    if (aorglat.ge.0) then ! region in northern hemisphere
		       maplxlat = latl
		       maprxlat = latl
		       mapuylon = lonl
		       maplylon = aorglon
		    else
		       if (aorglat.lt.0) then ! region in southern hemisphere
			  maplxlat = lath
			  maprxlat = lath
			  mapuylon = aorglon
			  maplylon = lonl
		       else
			  goto 1002
		       endif
		    endif
		 endif
	      else		! polar region
		 mapuylon = 0.
		 maplylon = 180.
		 if (poleflag.eq.1) then ! north pole
		    aorglat = lath
		    aorglon = 180.
		    maplxlon = 90.
		    maplxlat = latl
		    maprxlon = -90.
		    maprxlat = latl
		    mapuylat = latl
		    maplylat = latl
		 else
		    if (poleflag.eq.2) then ! south pole
		       aorglat = latl
		       aorglon = 0.
		       maplxlon = -90.
		       maplxlat = lath
		       maprxlon = 90.
		       maprxlat = lath
		       mapuylat = lath
		       maplylat = lath
		    else
		       goto 1002
		    endif
		 endif
	      endif
c
c        left most x value
c
	      call lambert1(maplxlat,maplxlon,x0,y0,aorglat,aorglon,projt)
	      lmostx = x0
c
c        right most x value
c
	      call lambert1(maprxlat,maprxlon,x0,y0,aorglat,aorglon,projt)
	      rmostx = x0
c
c        highest y value 
c
	      call lambert1(mapuylat,mapuylon,x0,y0,aorglat,aorglon,projt)
	      umosty = y0
c
c        lowest  y value 	
c
	      call lambert1(maplylat,maplylon,x0,y0,aorglat,aorglon,projt)
	      lmosty = y0
c
	   else if (projt.eq.5) then !   SAR polar stereographic
	      if (regnum.ge.200) goto 1002 ! not a polar region
	      trans = 0.
c              ascale = 8.9          ! 8.9 km/pixel (ers-1)
	      ascale = 8.9/2.0	! 4.45 km/pixel (SASS/NSCAT/Seawinds eggs)
	      if (negg.eq.1) ascale = 8.9/4.0	! 2.225 km/pixel (Seawinds slices)
	      bscale = ascale
	      write (*,*) 'Polar Stereographic pixel spacing: ',ascale,bscale,' km/pixel.'
	      if (((regnum.ge.100).and.(regnum.lt.110)).or.
	1	   (poleflag.eq.2)) then ! south pole
		 xdeg = 0.0
		 ydeg = -70.0
		 maplxlat = lath
		 maplxlon = -90.
		 maprxlat = lath
		 maprxlon = 90.
		 mapuylat = lath
		 mapuylon = xdeg
		 maplylat = lath
		 maplylon = 180.
	      else if (((regnum.ge.110).and.(regnum.lt.120)).or.
	1	      (poleflag.eq.1)) then !north pole
		 xdeg = -45.0
		 ydeg = 70.0
		 maplxlat = latl
		 maplxlon = -135.
		 maprxlat = latl
		 maprxlon = 45.
		 mapuylat = latl
		 mapuylon = 135.
		 maplylat = latl
		 maplylon = xdeg
	      endif
	      aorglon = xdeg
	      aorglat = ydeg

	      print *,'Polster 1',xdeg,ydeg,aorglon,aorglat,maplxlat,maplxlon,maprxlat,maprxlon,mapuylat,mapuylon,maplylat,maplylon
c
c        left most x value
c
	      call polster(maplxlon,maplxlat,x0,y0,aorglon,aorglat)
	      lmostx = x0
	      print *,'Polster 0',maplxlon,maplxlat,x0,y0,aorglon,aorglat
c
c        right most x value
c
	      call polster(maprxlon,maprxlat,x0,y0,aorglon,aorglat)
	      rmostx = x0
c
c       highest y value 
c
	      call polster(mapuylon,mapuylat,x0,y0,aorglon,aorglat)
	      umosty = y0
c
c        lowest  y value 	
c
	      call polster(maplylon,maplylat,x0,y0,aorglon,aorglat)
	      lmosty = y0

	      print *,'Polster 2',lmostx,rmostx,umosty,lmosty

c
	   else if (projt.eq.11.or.projt.eq.12.or.projt.eq.13) then !  projection type: EASE
	      trans = 0.
c
c  select ease grid parameters
c
	   if (pfile) then
	      read(2,*) nease
	   else
	      if (argc.lt.argn) then
		 write (*,11)
 11		 format(' Enter EASE grid resolution factor: ',
	1	      '(2**n * 1.5 km, N=4 => 24 km) ',$)
		 read (*,*) nease
	      else
		 call getarg(argn, neasech)
		 argn = argn + 1
		 read(neasech,'(i2)') nease
	      endif 
	   endif
	      projt = regnum - 300 ! for standard projection coding in putsir
c       !  11 = North, 12 = South, 13 = World
	      write (*,*) 'EASE grid resolution factor:  ',nease
	      write (*,*) 'EASE gridtype (11=north,12=south,13=globe):  ',projt
c       
	      if (projt.eq.11) then ! ease grid north
		 nsx=720*2.**(4-nease)+1
		 nsy=720*2.**(4-nease)+1
		 ascale=2.d0*6371.228d0/(25.067525d0*2.d0**(nease-4)) !
		 bscale=25.067525d0*2.d0**(nease-4) ! 
		 xdeg=360.0*2.**(4-nease)
		 ydeg=360.0*2.**(4-nease)
		 a0=-xdeg
		 b0=-ydeg
		 xdim = 10*int((nsx/ascale+10.)/10.)
		 ydim = 10*int((nsy/bscale+10.)/10.)
	      else if (projt.eq.12) then ! ease grid south
		 nsx=720*2.**(4-nease)+1
		 nsy=720*2.**(4-nease)+1
		 ascale=2.0d0*6371.228d0/(25.067525d0*2.d0**(nease-4))
		 bscale=25.067525d0*2.d0**(nease-4)
		 xdeg=360.0*2.**(4-nease)
		 ydeg=360.0*2.**(4-nease)
		 a0=-xdeg
		 b0=-ydeg
		 xdim = 10*int((nsx/ascale+10.)/10.)
		 ydim = 10*int((nsy/bscale+10.)/10.)
	      else if (projt.eq.13) then ! ease grid cylindrical
		 nsx=1382*2.**(4-nease)+1
		 nsy=586*2.**(4-nease)
		 ascale=6371.228d0/(25.067525d0*2.d0**(nease-4))
		 bscale=25.067525d0*2.d0**(nease-4)
		 xdeg=691.0*2.**(4-nease)
		 ydeg=292.5*2.**(4-nease)
		 a0=-xdeg
		 b0=-ydeg
		 xdim = 10*int((nsx/ascale+10.)/10.)
		 ydim = 10*int((nsy/bscale+10.)/10.)
	      else
		 write (*,*) '*** Error selecting EASE Grid region code ***'
		 stop
	      endif
	      aorglon=xdeg
	      aorglat=ydeg
	      
	   else			! unknown projection option
	      write (*,*)
	      write (*,*) '***Invalid projection number.'
	      goto 1002
	   endif
c       
c	make map dimensions an even integer divisible by both grid size and sectioning parameter
c       
	   if (projt.ne.0) then
	      write (*,*) 'Region geometry (in km): (raw computations)'
	      write (*,*) '  upper-most y ',umosty
	      write (*,*) '  lower-most y ',lmosty
	      write (*,*) '  right-most x ',rmostx
	      write (*,*) '  left-most  x ',lmostx
	   endif
c
	   if (projt.lt.10) then ! don't need this code section for EASE
	      temp = (lmostx-100.)/100.
	      lmostx = int(temp)*100.
	      temp = (rmostx+100.)/100.
	      rmostx = int(temp)*100.
	      temp = (lmosty-100.)/100.
	      lmosty = int(temp)*100.
	      temp = (umosty+100.)/100.
	      umosty = int(temp)*100.
c
	      if (projt.ne.0.0) then
		 write (*,*) 'Region geometry (in km): (after smoothed dimensioning)'
		 write (*,*) '  upper-most y ',umosty
		 write (*,*) '  lower-most y ',lmosty
		 write (*,*) '  right-most x ',rmostx
		 write (*,*) '  left-most  x ',lmostx
c
c	lower left corner
c
		 a0 = lmostx
		 b0 = lmosty
c       
c	image dimensions
c
		 xdim = abs(lmostx)+abs(rmostx)
		 ydim = abs(lmosty)+abs(umosty)
c
c       pixel size
c
		 if ((projt.eq.1).or.(projt.eq.2)) then
		    nsy = 10*int((ydim*bscale+10.)/10.)
		    nsx = 10*int((xdim*ascale+10.)/10.)
		 else if (projt.eq.5) then
		    nsy = 10*int((ydim/bscale+10.)/10.)
		    nsx = 10*int((ydim/ascale+10.)/10.)
		 endif
c
c	origin
c
		 xdeg=aorglon
		 ydeg=aorglat
	      endif
	   endif
c*******************************************************
c
c       select land/sea flagged data
c
	   toil=3    ! flags not used
c	   if (argc.lt.argn) then
c	      write (*,1) 'Enter toil flag (0=sea,1=land,2=ice,3=all) '
c	      read(*,*) toil
c	   else
c	      call getarg(argn,toilch)
c	      argn = argn + 1
c	      read(toilch,'(i1)') toil
c	      write (*,*) 'Toil flag (0=sea,1=land,3=both):  ',toil
c	   endif
	   write(id,'(''  Toil_flag='',I2)') toil
c
c       select ascending/descending data
c
	   iasc=0
	   if (pfile) then
	      read(2,*) iasc
	      write (*,*) 'AscDesc flag (0=both,1=asc,2=desc):  ',iasc
	   else
	      if (argc.lt.argn) then
		 write (*,1) 'Enter AscDesc flag (0=both,  1=asc only, 2=desc only,3=morn only, 4=even only) '
		 read(*,*) iasc
	      else
		 call getarg(argn,toilch)
		 argn = argn + 1
		 read(toilch,'(i1)') iasc
		 write (*,*) 'AscDesc flag (0=both,1=asc,2=desc,3=morn,4=eve):  ',iasc
	      endif
	   endif
	   write(id,'(''  AscDesc_flag='',I2)') iasc
c
c       select beam (selects frequency and polarization for SSMI)
c
	   if (pfile) then
	      read(2,*) ibeam
	      write (*,*) 'Beam index (1=19V,2=19H,3=22V,4=37V,5=37H,6=85V,7=85H):  ',ibeam
	   else
	      if (argc.lt.argn) then
		 write (*,1) 'Select beam (1=19V,2=19H,3=22V,4=37V,5=37H,6=85V,7=85H) '
		 read(*,*) ibeam
	      else
		 call getarg(argn,toilch)
		 argn = argn + 1
		 read(toilch,'(i1)') ibeam
		 write (*,*) 'Beam index (1=19V,2=19H,3=22V,4=37V,5=37H,6=85V,7=85H):  ',ibeam
	      endif
	   endif
	   ipolar=0   ! h pol
	   if (ibeam.eq.1.or.ibeam.eq.3.or.ibeam.eq.4.or.ibeam.eq.6) ipolar=1 ! v pol
	   write(id,'(''  Polarization='',I1)') ipolar
	   write(id,'(''  Beam_index='',I1)') ibeam
           nits=20
	   if (ibeam.ge.4) nits=30
	   write(id,'('' Max_iterations='',I3)') nits
	   if (ibeam.lt.6) then
	      if (projt.eq.1.or.projt.eq.2) then
		 ascale = 1./8.9    ! 8.9 km/pixel (ers-1)
		 bscale=ascale
		 nsy = 10*int((ydim*bscale+10.)/10.)
		 nsx = 10*int((xdim*ascale+10.)/10.)
	      endif
	      if (projt.eq.5) then
		 ascale=8.9
		 bscale=ascale
		 nsy = 10*int((ydim/bscale+10.)/10.)
		 nsx = 10*int((ydim/ascale+10.)/10.)
	      endif
	   endif
	   
c
c     summarize region results
c
	   if (projt.ne.0) then
	      write (*,*) 'Origin (lat,lon) ',aorglat,aorglon
	      write (*,*) 'Offset x,y in km:',a0,b0
	      write (*,*) 'Array Dimensions in Km==> x ',xdim,' y ',ydim
	   endif
	   write (*,*) 'Size in pixels: (x,y) (lon,lat)',nsx,nsy
	   write (*,*)
c
c       set grid image size parameter
c
	   non_size=5		! number of enhanced pixels/non-enhanced pixel
c	   if (negg.eq.1) non_size=10
	   if (non_size*(nsx/non_size).ne.nsx.or.
	1	non_size*(nsy/non_size).ne.nsy) then
	      write (*,*) '*** WARNING ***'
	      write (*,*) '*** WARNING: non grid size parameter ',non_size,
	1	   ' does not evenly divide image size ',nsx,nsy
	      write (*,*) '*** WARNING ***'
	   endif
c
c       is this a section of a larger image?
c
           nsection=0
	   if (pfile) then
	      read(2,*) nsection
	      write (*,*) 'Sectioning code:  ',nsection
	   else
	      if (argc.lt.argn) then
		 write (*,1) 'Enter number of sections/pattern parameter (0=no sectioning) '
		 read(*,*) nsection
	      else
		 call getarg(argn,toilch)
		 argn = argn + 1
		 read(toilch,'(i4)') nsection
		 write (*,*) 'Sectioning code:  ',nsection
	      endif
	   endif
           if (nsection.eq.1) nsection=0
	   write(id,'(''  Sectioning_code='',I6)') nsection
	   if (nsection.gt.0) sections=.true.
c
c       save unsectioned projection info
c
	   ascale_s=ascale
	   bscale_s=bscale
	   a0_s=a0
	   b0_s=b0
	   xdeg_s=xdeg
	   ydeg_s=ydeg
	   nsx_s=nsx
	   nsy_s=nsy
c
	   nsect=mod(nsection,100)    ! number of sections
	   nt=nsection/100            ! section type code
c
c       for each output section (0=unsectioned region)
c
	   do isection=0,nsect
	      write (id,*) ' Begin_section_description'
              write(id,'(''   Section_id='',I2)') isection
c
	      if (isection.gt.0) then
c
c     recompute projection information based on sectioning
c
		 ascale=ascale_s
		 bscale=bscale_s
		 a0=a0_s
		 b0=b0_s
		 xdeg=xdeg_s
		 ydeg=ydeg_s
		 nsx=nsx_s
		 nsy=nsy_s
c
c       first compute pixel locations for sectioning
c
		 call section_pixels(isection,ix,iy,nsect,nt,0.1,
	1	      nsx,nsy,non_size,
	1	      nsx2,nsy2,ix1,iy1,ix2,iy2,jx1,jy1,jx2,jy2)
c
c     quantize projection parameters (same as in sir file header)
c
c                call proj_quan()
c
c     compute section projection info
c
		 if (projt.eq.1.or.projt.eq.2) then ! lambert
		    a02=(ix-1)/ascale+a0
		    b02=(iy-1)/bscale+b0
		    xdeg2=xdeg
		    ydeg2=ydeg
		    ascale2=ascale
		    bscale2=bscale
		 else if (projt.eq.5) then ! polar ster
		    a02=(ix-1)*ascale+a0
		    b02=(iy-1)*bscale+b0
		    xdeg2=xdeg
		    ydeg2=ydeg
		    ascale2=ascale
		    bscale2=bscale
		 else if (projt.eq.11.or.projt.eq.12.or.projt.eq.13) then ! ease grid
		    a02=a0+(ix-1.0)
		    b02=b0+(iy-1.0)
		    xdeg2=xdeg
		    ydeg2=ydeg
		    ascale2=ascale
		    bscale2=bscale
		 else		! image only and lat/lon
		    a02=(ix-1)*xdim/float(nsx)+a0
		    b02=(iy-1)*ydim/float(nsy)+b0
		    xdeg2=float(nsx2)*xdeg/float(nsx)
		    ydeg2=float(nsy2)*ydeg/float(nsy)
		    ascale2=xdeg2/float(nsx2)
		    bscale2=ydeg2/float(nsy2)
		 endif
c
		 aorglon=xdeg2
		 aorglat=ydeg2
		 nsx=nsx2
		 nsy=nsy2
		 a0=a02
		 b0=b02
		 xdim=nsx/ascale
		 ydim=nsy/bscale
		 if (projt.eq.5) then
		    xdim=nsx*ascale
		    ydim=nsy*bscale
		 endif
	      endif
c
	      write (*,*)
	      write (*,*) 'Sectioning: (x,y) ',isection,nsect
c       
c       write map projection info to output file
c
	      write(id,'(''   Project_type='',I2)') projt
	      write(id,'(''   Projection_origin_x='',G16.9)') aorglat
	      write(id,'(''   Projection_origin_y='',G16.9)') aorglon
	      write(id,'(''   Projection_offset_x='',G16.9)') a0
	      write(id,'(''   Projection_offset_y='',G16.9)') b0
	      write(id,'(''   Projection_scale_x='',G16.9)') ascale
	      write(id,'(''   Projection_scale_y='',G16.9)') bscale
	      write(id,'(''   Projection_dim_x='',I9)') xdim
	      write(id,'(''   Projection_dim_y='',I9)') ydim
	      write(id,'(''   Image_size_x='',I9)') nsx
	      write(id,'(''   Image_size_y='',I9)') nsy
	      if (isection.gt.0) then
		 write(id,'(''   Section_loc_pixels='',8(1x,I5))') ix1,iy1,ix2,iy2,jx1,jy1,jx2,jy2
	      endif
c
c       generate parameters for non-enhanced images
c
	      nsx2=nsx/non_size
	      nsy2=nsy/non_size
	      if (non_size*nsx2.ne.nsx.or.non_size*nsy2.ne.nsy) then
		 write (*,*) '*** WARNING: non grid size ',non_size,
	1	      ' does not evenly divid image size ',nsx,nsy
	      endif
	      ascale2=ascale
	      bscale2=bscale
	      if (projt.eq.0.or.projt.eq.1.or.projt.eq.2) then ! rect, lambert
		 ascale2=ascale/non_size
		 bscale2=bscale/non_size
	      else if (projt.eq.5) then	! stereographic
		 ascale2=ascale*non_size
		 bscale2=bscale*non_size
	      else
		 nsx2=nsx
		 nsy2=nsy
		 write (*,*) '*** WARNING ***'
		 write (*,*) '*** Projection type can not generate Non-enhanced parameters ***'
	      endif
c
c       compute grid pixel locations
c
		 ix1g=(ix1-1)/non_size+1
		 iy1g=(iy1-1)/non_size+1
		 ix2g=(ix2-1)/non_size+1
		 iy2g=(iy2-1)/non_size+1
		 jx1g=(jx1-1)/non_size+1
		 jy1g=(jy1-1)/non_size+1
		 jx2g=(jx2-1)/non_size+1
		 jy2g=(jy2-1)/non_size+1
c
c       write grid projection info to file
c
	      write(id,'(''   Grid_scale_x='',I3)') non_size
	      write(id,'(''   Grid_scale_y='',I3)') non_size
	      write(id,'(''   Grid_size_x='',I9)') nsx2
	      write(id,'(''   Grid_size_y='',I9)') nsy2
	      write(id,'(''   Grid_projection_origin_x='',G16.9)') aorglat
	      write(id,'(''   Grid_projection_origin_y='',G16.9)') aorglon
	      write(id,'(''   Grid_projection_offset_x='',G16.9)') a0
	      write(id,'(''   Grid_projection_offset_y='',G16.9)') b0
	      write(id,'(''   Grid_projection_scale_x='',G16.9)') ascale2
	      write(id,'(''   Grid_projection_scale_y='',G16.9)') bscale2
	      if (isection.gt.0) then
		 write(id,'(''   Section_grd_pixels='',8(1x,I5))') ix1g,iy1g,ix2g,iy2g,jx1g,jy1g,jx2g,jy2g
	      endif
c       
	      write (*,*)
c
c       for this region, generate product data file names
c       Here are some standard region names
c
	      if (regnum.eq.100) then
		 reg='Ant'
	      else if (regnum.eq.110) then
		 reg='Arc'
	      else if (regnum.eq.112) then
		 reg='NHe'
	      else if (regnum.eq.202) then
		 reg='Grn'
	      else if (regnum.eq.203) then
		 reg='Ala'
	      else if (regnum.eq.204) then
		 reg='CAm'
	      else if (regnum.eq.205) then
		 reg='NAm'
	      else if (regnum.eq.206) then
		 reg='SAm'
	      else if (regnum.eq.207) then
		 reg='NAf'
	      else if (regnum.eq.208) then
		 reg='SAf'
	      else if (regnum.eq.209) then
		 reg='Sib'
	      else if (regnum.eq.210) then
		 reg='Eur'
	      else if (regnum.eq.211) then
		 reg='SAs'
	      else if (regnum.eq.212) then
		 reg='ChJ'
	      else if (regnum.eq.213) then
		 reg='Ind'
	      else if (regnum.eq.214) then
		 reg='Aus'
	      else if (regnum.eq.256) then
		 reg='Ber'
	      else if (regnum.eq.311) then
		 reg='EaN'
	      else if (regnum.eq.312) then
		 reg='EaS'
	      else if (regnum.eq.313) then
		 reg='EaG'
	      else
		 reg=regname(1:3) ! non-standard region
	      endif
c
	      iy=mod(year,100)
	      cpol=char(ibeam+48)
	      write(cegg,'(I2.2,X)') F_num
c
c       write split time to file
c
	      if (iasc.gt.2) then
		 tsplit1=0.0
		 tsplit2=12.0
		 if (regnum.eq.100.or.regnum.eq.206.or.  ! Ant, SAm
     $		     regnum.eq.208.or.regnum.eq.214.or.  ! SAf, Aus
     $		     regnum.eq.213 ) then  ! Ind
		    tsplit1=0.0
		    tsplit2=12.0
		 endif
		 write(id,'(''   Local_time_split1='',G16.9)') tsplit1
		 write(id,'(''   Local_time_split2='',G16.9)') tsplit2
	      endif
c
c       all standard product file names are created, whether used or not
c
	      if (isection.gt.0) then
		 write (setname,144) cegg,cpol,reg,iy,dstart,dend,nsection,isection
 144		 format('F',a2,a1,'-',a3,I2.2,'-',I3.3,'-',I3.3,'-s',I3.3,'-',I2.2,'.setup')
		 write (lisname,145) cegg,cpol,reg,iy,dstart,dend,nsection,isection
 145		 format('F',a2,a1,'-',a3,I2.2,'-',I3.3,'-',I3.3,'-s',I3.3,'-',I2.2,'.lis')
		 write (a_name,146) cegg,cpol,'a',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (b_name,146) cegg,cpol,'b',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (i_name,146) cegg,cpol,'I',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (j_name,146) cegg,cpol,'J',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (c_name,146) cegg,cpol,'C',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (p_name,146) cegg,cpol,'p',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (v_name,146) cegg,cpol,'V',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (e_name,146) cegg,cpol,'E',reg,iy,dstart,dend,nsection,isection,'sir'
		 write (aa_name,146) cegg,cpol,'a',reg,iy,dstart,dend,nsection,isection,'ave'
		 write (bb_name,146) cegg,cpol,'b',reg,iy,dstart,dend,nsection,isection,'ave'
		 write (non_aname,146) cegg,cpol,'a',reg,iy,dstart,dend,nsection,isection,'non'
		 write (non_bname,146) cegg,cpol,'b',reg,iy,dstart,dend,nsection,isection,'non'
		 write (non_vname,146) cegg,cpol,'V',reg,iy,dstart,dend,nsection,isection,'non'
		 write (grd_aname,146) cegg,cpol,'a',reg,iy,dstart,dend,nsection,isection,'grd'
		 write (grd_bname,146) cegg,cpol,'b',reg,iy,dstart,dend,nsection,isection,'grd'
		 write (grd_vname,146) cegg,cpol,'V',reg,iy,dstart,dend,nsection,isection,'grd'
		 write (grd_iname,146) cegg,cpol,'I',reg,iy,dstart,dend,nsection,isection,'grd'
		 write (grd_jname,146) cegg,cpol,'J',reg,iy,dstart,dend,nsection,isection,'grd'
		 write (grd_cname,146) cegg,cpol,'C',reg,iy,dstart,dend,nsection,isection,'grd'
		 write (grd_pname,146) cegg,cpol,'p',reg,iy,dstart,dend,nsection,isection,'grd'
 146		 format('F',a2,a1,'-',a1,'-',a3,I2.2,'-',I3.3,'-',I3.3,'-s',I3.3,'-',I2.2,'.',a3)
	      else
		 write (setname,44) cegg,cpol,reg,iy,dstart,dend
 44		 format('F',a2,a1,'-',a3,I2.2,'-',I3.3,'-',I3.3,'.setup')
		 write (lisname,45) cegg,cpol,reg,iy,dstart,dend
 45		 format('F',a2,a1,'-',a3,I2.2,'-',I3.3,'-',I3.3,'.lis')
		 write (a_name,46) cegg,cpol,'a',reg,iy,dstart,dend,'sir'
		 write (b_name,46) cegg,cpol,'b',reg,iy,dstart,dend,'sir'
		 write (i_name,46) cegg,cpol,'I',reg,iy,dstart,dend,'sir'
		 write (j_name,46) cegg,cpol,'J',reg,iy,dstart,dend,'sir'
		 write (c_name,46) cegg,cpol,'C',reg,iy,dstart,dend,'sir'
		 write (p_name,46) cegg,cpol,'p',reg,iy,dstart,dend,'sir'
		 write (v_name,46) cegg,cpol,'V',reg,iy,dstart,dend,'sir'
		 write (e_name,46) cegg,cpol,'E',reg,iy,dstart,dend,'sir'
		 write (aa_name,46) cegg,cpol,'a',reg,iy,dstart,dend,'ave'
		 write (bb_name,46) cegg,cpol,'b',reg,iy,dstart,dend,'ave'
		 write (non_aname,46) cegg,cpol,'a',reg,iy,dstart,dend,'non'
		 write (non_bname,46) cegg,cpol,'b',reg,iy,dstart,dend,'non'
		 write (non_vname,46) cegg,cpol,'V',reg,iy,dstart,dend,'non'
		 write (grd_aname,46) cegg,cpol,'a',reg,iy,dstart,dend,'grd'
		 write (grd_bname,46) cegg,cpol,'b',reg,iy,dstart,dend,'grd'
		 write (grd_vname,46) cegg,cpol,'V',reg,iy,dstart,dend,'grd'
		 write (grd_iname,46) cegg,cpol,'I',reg,iy,dstart,dend,'grd'
		 write (grd_jname,46) cegg,cpol,'J',reg,iy,dstart,dend,'grd'
		 write (grd_cname,46) cegg,cpol,'C',reg,iy,dstart,dend,'grd'
		 write (grd_pname,46) cegg,cpol,'p',reg,iy,dstart,dend,'grd'
 46		 format('F',a2,a1,'-',a1,'-',a3,I2.2,'-',I3.3,'-',I3.3,'.',a3)
	      endif
c
c       modify file name if ascending/descending or morn/even only.  Unfortunately, by convention
c       the modification overwrites part of the instrument ID
c
	      if (iasc.ne.0) then

		 cpol='a' ! asc
		 if (iasc.eq.2) cpol='d' ! desc
		 if (iasc.eq.3) cpol='m' ! morning
		 if (iasc.eq.4) cpol='e' ! evening
		 setname(2:2)=cpol
		 lisname(2:2)=cpol
		 a_name(2:2)=cpol
		 b_name(2:2)=cpol
		 i_name(2:2)=cpol
		 j_name(2:2)=cpol
		 c_name(2:2)=cpol
		 p_name(2:2)=cpol
		 v_name(2:2)=cpol
		 e_name(2:2)=cpol
		 aa_name(2:2)=cpol
		 bb_name(2:2)=cpol
		 non_aname(2:2)=cpol
		 non_bname(2:2)=cpol
		 non_vname(2:2)=cpol
		 grd_aname(2:2)=cpol
		 grd_bname(2:2)=cpol
		 grd_vname(2:2)=cpol
		 grd_iname(2:2)=cpol
		 grd_jname(2:2)=cpol
		 grd_cname(2:2)=cpol
		 grd_pname(2:2)=cpol
	      endif
c
c       save *-a-*.sir, .ave names for making .gif files
c
	      name_store(iregion)=a_name
	      name_store2(iregion)=aa_name
c       
	      write (*,*) 'Output setup file:"',setname(1:length(setname)),'"'
	      write (*,*) 'Output A file:    "',a_name(1:length(a_name)),'"'
c	      write (*,*) 'Output B file:    "',b_name(1:length(b_name)),'"'
	      write (*,*) 'Output C file:    "',c_name(1:length(c_name)),'"'
	      write (*,*) 'Output I file:    "',i_name(1:length(i_name)),'"'
	      write (*,*) 'Output J file:    "',j_name(1:length(j_name)),'"'
	      write (*,*) 'Output P file:    "',p_name(1:length(p_name)),'"'
	      write (*,*) 'Output E file:    "',e_name(1:length(e_name)),'"'
	      write (*,*) 'Output V file:    "',v_name(1:length(v_name)),'"'
	      write (*,*) 'Output A ave file:"',aa_name(1:length(aa_name)),'"'
c	      write (*,*) 'Output B ave file:"',bb_name(1:length(bb_name)),'"'
	      write (*,*) 'Output A non file:"',non_aname(1:length(non_aname)),'"'
c	      write (*,*) 'Output B non file:"',non_bname(1:length(non_bname)),'"'
	      write (*,*) 'Output V non file:"',non_vname(1:length(non_vname)),'"'
	      write (*,*) 'Output A grd file:"',grd_aname(1:length(grd_aname)),'"'
c	      write (*,*) 'Output B grd file:"',grd_bname(1:length(grd_bname)),'"'
	      write (*,*) 'Output V grd file:"',grd_vname(1:length(grd_vname)),'"'
	      write (*,*) 'Output I grd file:"',grd_iname(1:length(grd_iname)),'"'
	      write (*,*) 'Output J grd file:"',grd_jname(1:length(grd_jname)),'"'
	      write (*,*) 'Output C grd file:"',grd_cname(1:length(grd_cname)),'"'
	      write (*,*) 'Output P grd file:"',grd_pname(1:length(grd_pname)),'"'
	      write (*,*) 'Output lis file:  "',lisname(1:length(lisname)),'"'
c
	      write (id,*) '  Setup_file=',setname(1:length(setname))
	      write (id,*) '  Begin_product_file_names'
	      write (id,*) '   SIRF_A_file=',a_name(1:length(a_name))
c	      write (id,*) '   SIRF_B_file=',b_name(1:length(b_name))
	      if (negg.ne.0) write (id,*) '   SIRF_C_file=',c_name(1:length(c_name))
	      write (id,*) '   SIRF_I_file=',i_name(1:length(i_name))
	      write (id,*) '   SIRF_J_file=',j_name(1:length(j_name))
	      write (id,*) '   SIRF_E_file=',e_name(1:length(e_name))
	      write (id,*) '   SIRF_V_file=',v_name(1:length(v_name))
	      write (id,*) '   SIRF_P_file=',p_name(1:length(p_name))
	      write (id,*) '   AVE_A_file=',aa_name(1:length(aa_name))
c	      write (id,*) '   AVE_B_file=',bb_name(1:length(bb_name))
	      write (id,*) '   GRD_A_file=',grd_aname(1:length(grd_aname))
c	      write (id,*) '   GRD_B_file=',grd_bname(1:length(grd_bname))
	      write (id,*) '   GRD_V_file=',grd_vname(1:length(grd_vname))
	      write (id,*) '   GRD_I_file=',grd_iname(1:length(grd_iname))
	      write (id,*) '   GRD_J_file=',grd_jname(1:length(grd_jname))
	      write (id,*) '   GRD_C_file=',grd_cname(1:length(grd_cname))
	      write (id,*) '   GRD_P_file=',grd_pname(1:length(grd_pname))
	      write (id,*) '   NON_A_file=',non_aname(1:length(non_aname))
c	      write (id,*) '   NON_B_file=',non_bname(1:length(non_bname))
	      write (id,*) '   NON_V_file=',non_vname(1:length(non_vname))
	      write (id,*) '   Info_file=',lisname(1:length(lisname))
	      write (id,*) '  End_product_file_names'
c
c       write out sirf command to job script
c
	      fnamel=setname(1:length(setname))//'.out'
	      if (nsection.eq.0.or.nsection.gt.0.and.isection.gt.0) then
		 write (idj,'('' echo "SIRFing '',a,''"'')') setname(1:length(setname))
c		 write (idj,'(1x,a,'' '',a,'' > '',a)') sirf_name(1:length(sirf_name)),
c	1	      setname(1:length(setname)),fnamel(1:length(fnamel))
c
		 write (idj,'('' if '',a,'' '',a,'' > '',a)') sirf_name(1:length(sirf_name)),
	1	      setname(1:length(setname)),fnamel(1:length(fnamel))
		 write (idj,'('' then '')')        ! SIRF successfull
		 write (idj,'(''  echo "SIRF successfully completed"'')') 
		 write (idj,'('' else '')')
		 write (idj,'(''  SIRFsOK=1 '')')  ! SIRF not successfull
		 write (idj,'('' fi '')')
	      endif
c
	      write (id,*) ' End_section_description'
	      ircnt=ircnt+1
	   end do   ! end section loop
	   write (id,'('' End_region_description'')')
	end do      ! end region loop
	write (id,'(''End_description'')')
	if (pfile) close(2)
c
	write (*,*)
	write (*,*) 'Total regional images:', ircnt,' Regions:',nregions
c
c       write out conclusion to job script
c
	if (sections) then
	   write (idj,'('' echo "Running combine_sect on '',a,''"'')') fname(1:length(fname))
	   fnamel=fname(1:length(fname))//'.comb_out'
	   write (idj,'('' if combine_sect '',a,'' > '',a)') 
	1	fname(1:length(fname)),fnamel(1:length(fnamel))
	   write (idj,'('' then'')')
	   write (idj,'(''  echo "combine_sect successfully completed"'')') 
	   write (idj,'(''  echo "Running clean_sect on '',a,''"'')') fname(1:length(fname))
	   fnamel=fname(1:length(fname))//'.clean_out'
	   write (idj,'(''  clean_sect '',a,'' > '',a)') 
	1	fname(1:length(fname)),fnamel(1:length(fnamel))
	   write (idj,'(''  echo "clean_sect completed"'')') 
	   write (idj,'('' fi'')')
	endif
	write (idj,'('' if [ $SIRFsOK = 0 ]'')')
	write (idj,'('' then'')')
	write (idj,'(''  echo "Running clean_setup on '',a,''"'')') fname(1:length(fname))
	write (idj,'(''  clean_setup '',a,'' > '',a)') fname(1:length(fname)),
	1    fnamel(1:length(fnamel))
	write (idj,'(''  echo "clean_setup completed"'')') 
c	write (idj,'('' echo "land masking '',a,''"'')') fname(1:length(fname))
c	fnamel=fname(1:length(fname))//'.mask_out'
c	write (idj,'('' meta_landmask '',a,'' > '',a)') fname(1:length(fname)),
c	1    fnamel(1:length(fnamel))
	do iregion=1,nregions
	   write (idj,'(''  echo "Running sir2gif on '',a,''"'')') name_store2(iregion)(1:length(name_store2(iregion)))
	   write (idj,'(''  sir2gif '',a,'' '',a,'' > '',a)') S2G,name_store2(iregion)(1:length(name_store2(iregion))),name_store2(iregion)(1:length(name_store2(iregion)))//'.gif.out'
	   write (idj,'(''  echo "Running sir2gif on '',a,''"'')') name_store(iregion)(1:length(name_store(iregion)))
	   write (idj,'(''  sir2gif '',a,'' '',a,'' > '',a)') S2G,name_store(iregion)(1:length(name_store(iregion))),name_store(iregion)(1:length(name_store(iregion)))//'.gif.out'
	end do
	write (idj,'('' else'')')
	write (idj,'(''  echo "*** job failed due to failure of one or more SIRFs"'')')
	write (idj,'('' fi'')')
	write (idj,'(''else'')')
	write (idj,'('' echo "*** job failed during setup phase"'')')
	write (idj,'('' echo "job execution completed"'')')
	write (idj,'(''fi'')')
c
	return
c
 1002	write (*,*) '*** Error in specified parameters'
	stop
        end
c
c
c ***************************************************************************
c
        subroutine get_file_names(id,argc,argn)
c
c      get input file names
c
	implicit none
c
	integer id,argc,argn
c
	integer count
	logical last
	character*120 fname
c
	integer length
c
	write (id,'(''Begin_input_file_list'')') 
c

	if (argc.lt.argn) then
 10	   continue
	   write (*,110)
 110	   format(1x,'Enter file name of list input file: (blank or NONE for manual input) ',$)
	   read(*,'(a120)') fname
	else
	   call getarg(argn,fname)
	   argn = argn + 1
	endif
c
	if ((fname.ne.' ').and.(fname(1:4).ne.'NONE').and.
	1   (fname(1:4).ne.'none')) then
c
c       read input file names from list input file
c
	   write (*,*) 'Opening input list file "',fname(1:length(fname)),'"'
	   open(unit=9,file=fname,status='old',form='formatted',err=999)
c
	   last=.true.
	   count=0
	   do while(last)
	      read (9,'(A)',err=99,end=99) fname
	      if (fname.ne.' ') then
		 write(id,'('' Input_file='',a)') fname(1:length(fname))
		 write(*,'(''Input_file="'',a,''"'')') fname(1:length(fname))
		 count=count+1
	      else
		 last=.false.
	      endif
	   end do
 99	   continue
	   close(9)
c
	else
c
	   last=.true.
	   count=0
	   if (argc.lt.argn) then
c       
	      write (*,*)
	      write (*,*) 'Enter list of L1B file names (blank to end input)'
c       
	      do while(last)
		 write (*,111) count
 111		 format(1x,'Enter input file name #',I3,': ',$)
		 read(*,'(a120)') fname
		 if (fname.ne.' ') then
		    count=count+1
		    write(id,'('' Input_file='',a)') fname(1:length(fname))
		 else
		    last=.false.
		 endif
	      end do
c       
	   else
	      do while(last)
		 call getarg(argn,fname)
		 argn = argn + 1
		 count=count+1
		 write(id,'('' Input_file='',a)') fname(1:length(fname))
		 write(*,'(''Input_file="'',a,''"'')') fname(1:length(fname))
		 if (argc.lt.argn) last=.false.
	      end do
	   endif
	endif
	write (id,'(''End_input_file_list'')') 
c
	write(*,*)
	write(*,*) 'Total number of input files: ',count
c
	return
 999	continue
	write (*,*) '*** Error opening input list file "',fname(1:length(fname)),'"'
	goto 10
c
	end
c
c
	subroutine section_pixels(isection,ix,iy,nsect,nt,alpha,
     $     nsx,nsy,non_size,nsx2,nsy2,
     $     ix1,iy1,ix2,iy2,jx1,jy1,jx2,jy2)
c
c       computes the pixel locations of sectioned images
c
c       inputs:
c        isection: section number (1...nsect)
c        nsect:    number of sections (valid values: 1,2,3,4,6,8,9,12,15,16,18,20)
c        nt:       sectioning code (0=vertical orientation,1=horizontal)
c        alpha:    overlap ratio
c        nsx,nsy:  image size in pixels
c        non_size: number of grid pixels/image pixel
c
c       outputs:
c        ix,iy:    lower-left corner of the isection'th image
c        nsx2,nsy2: image size for isection'th image
c        ix1..iy2: lower-left,upper right corner of useful pixels of section
c        jx1..jy2: lower-left,upper right corner of section in final image
c
	ix=1
	iy=1
c
	ix1=1			! section pixel range
	iy1=1
	ix2=nsx
	iy2=nsy
	jx1=1			! destination pixel range
	jy1=1
	jx2=nsx
	jy2=nsy
        nsx2=nsx
        nsy2=nsy
	if (nsect.eq.1) return
c
        if (nsect.eq.2) then
           nx=1
           ny=2
        elseif (nsect.eq.3) then
           nx=1
           ny=3
        elseif (nsect.eq.4) then
           nx=2
           ny=2
        elseif (nsect.eq.6) then
           nx=2
           ny=3
        elseif (nsect.eq.8) then
           nx=2
           ny=4
        elseif (nsect.eq.9) then
           nx=3
           ny=3
        elseif (nsect.eq.12) then
           nx=3
           ny=4
        elseif (nsect.eq.15) then
           nx=3
           ny=5
        elseif (nsect.eq.16) then
           nx=4
           ny=4
        elseif (nsect.eq.18) then
           nx=6
           ny=3
        elseif (nsect.eq.20) then
           nx=4
           ny=5
        else
           write (*,*) '*** ERROR: invalid number of sections',nsect
           nsect=1
           return
        endif   
c
        if (isection.gt.nsect) then
           write (*,*) '*** ERROR: invalid sectioning',isection,nsect
           return
        endif
c
        if (nt.eq.1) then       ! horizontal orientaion rather than vertical
           n=nx
           nx=ny
           ny=n
        endif
c
        inx=mod(isection-1,nx)+1
        iny=(isection-1)/nx+1
c
        ny1=nsy/ny
        if (non_size*(ny1/non_size).ne.ny1) ny1=non_size*(1+ny1/non_size)
        nay=alpha*nsy
        nay=non_size*(nay/non_size)
c
        if (nx.gt.1) then
           nx1=nsx/nx
           if (non_size*(nx1/non_size).lt.nx1) nx1=non_size*(1+nx1/non_size)
           if (nx*nx1.lt.nsx) nx1=nx1+non_size
           n=alpha*nsx
           nax=non_size*(n/non_size)
           if (nax.lt.n) nax=nax+non_size
           nsx2=nx1+nax
           if (inx.ne.1.and.inx.ne.nx) nsx2=nsx2+nax
           jx1=(inx-1)*nx1+1
           jx2=min(inx*nx1,nsx)
           ix1=nax+1
           if (inx.eq.1) ix1=1
           ix=jx1-ix1+1
           ix2=ix1+nx1-1
        endif
c
        if (ny.gt.1) then
           ny1=nsy/ny
           if (non_size*(ny1/non_size).lt.ny1) ny1=non_size*(1+ny1/non_size)
           if (ny*ny1.lt.nsy) ny1=ny1+non_size
           n=alpha*nsy
           nay=non_size*(n/non_size)
           if (nay.lt.n) nay=nay+non_size
           nsy2=ny1+nay
           if (iny.ne.1.and.iny.ne.ny) nsy2=nsy2+nay
           jy1=(iny-1)*ny1+1
           jy2=min(iny*ny1,nsy)
           iy1=nay+1
           if (iny.eq.1) iy1=1
           iy=jy1-iy1+1
           iy2=iy1+ny1-1
        endif
c
	return
	end

