/* (c) copyright 2014 David G. Long, Brigham Young University */
/*****************************************************************
  Filename:  meas_meta_bgi.c    MEaSURES project

  program to generate Backus-Gilbert Inversion (bgi) images from
  setup files generated by the ssmi_meta_setup program

  Written by DGL at BYU 02/25/2014 + modified from ssmi_meta_bgi.c
  Revised by DGL at BYU 05/16/2015 + use intermediate dump file output
  Revised by DGL at BYU 06/21/2014 + modified gain thresholding and response rejection
  Revised by DGL at BYU 07/04/2014 + removed extra memory array allocations, reduced redundant computation of z
  Revised by DGL at BYU 07/24/2014 + changed default parameter settings, measurements that span horizontal edge
  Revised by DGL at BYU 08/02/2014 + folded in changes by Brodzik
  Revised by DGL at BYU 08/16/2014 + revised error handling, optional INFOfile out

******************************************************************/

#include <stdlib.h>
#include <stdio.h>
#ifdef JANUSicc
#include <mathimf.h>
#else
#include <math.h>
#endif

#include <string.h>
#include <time.h>
#include <netcdf.h>

#include "cetb.h"
#include "cetb_file.h"
#include "ezdump.h"
#include "sir3.h"

#define NRANSI
#include "nr.h"
#include "nrutil.h"

static void dlubksb(double **a, int n, int *indx, double b[]);
static void dludcmp(double **a, int n, int *indx, double *d);

#define VERSION 2.4

#define file_savings 1.00     /* measurement file savings ratio */
#define REL_EOF   2           /* fseek relative to end of file */
#define REL_BEGIN 0           /* fseek relative to end of file */

#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))

/****************************************************************************/

/* some variables and their default values */

float a_init=180.0;           /* initial A (TB) value */
int   nits=30;                /* number of SIR iterations */
char  sensor_in[40];          /* sensor description string */
int   MAXFILL=1000;           /* maximum number of pixels in response */
int   HASAZANG=0;             /* azimuth angle data not included */
int   HS=20;                  /* measurement headersize in bytes */

/* the following BG parameters are subjectively set */

/* note that delta2 is not independent of bgi_gamma, but as long as it is not too far (within a few deg**2)
   from the true noise variance it can be held constant and bgi_gamma can be adjusted and will take care of
   any deviations in delta2 */

/* although the value of gamma is "subjectively" set, we have run tests for different values
 * of gamma and shown that the lower noise variance and most faithful reconstruction of the
 * original signal occur at .85*PI/2
 */

double bgi_gamma=0.85*M_PI*0.5;   /*0.85*0.5*3.1415926535 default BGI gamma parameter */
float delta2=1.0;                 /* default BGI assumed noise variance */
float omega=0.001;                /* BGI scale factor (fixed)*/
float ithres=0.125;               /* default minimum gain threshold */
float difthres=5.0;               /* BGI-AVE difference QA threshold */
int Nsize=0;                      /* (built into the code) */
float wscale=0.001;  /* pattern scale coversion factor int->float */

/****************************************************************************/

void eprintf(char *s)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,"%s",s);
  fflush(stdout);
  fprintf(stderr,"%s",s);
  fflush(stderr);
}

void eprintfi(char *s, int a)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s,a);
  fflush(stdout);
  fprintf(stderr,s,a);
  fflush(stderr);
}

void eprintfc(char *s, char *a)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s,a);
  fflush(stdout);
  fprintf(stderr,s,a);
  fflush(stderr);
}

/* function prototypes */

void count_hits(int count, int fill_array[], short int response_array[], float ithres, int cnt[], int *mdim, int nsx);

void make_indx(int nmax, int count, int fill_array[], short int response_array[], float ithres, char **indx, char * pointer);

void Ferror(int i);

void filter(float *val, int size, int opt, int nsx, int nsy, float
	    *temp, float thres, float missing);

void no_trailing_blanks(char *s);

char *addpath(char *outpath, char *name, char *temp);

/****************************************************************************/

/* global array variables used for storing images*/

float *a_val, *a_temp;
int *cnts;

/* other global variables */

FILE *imf, *omf;
long int nspace;

/****************************************************************************/

/* these definitions simplify indexing of patarr 
   patarr3d stores the SRF(x,y) for measurement n
   patarr2d indexes the SRF as a list for measurement n */

#define patarr3d(x,y,n) patarr[x-1+(y-1)*mdim+(n-1)*mdim*mdim]
#define patarr2d(k,n) patarr[k+(n-1)*mdim*mdim]

/****************************************************************************/

/* main program */

int main(int argc, char **argv)
{

  char *file_in;
  char outpath[FILENAME_MAX];

  float latl, lonl, lath, lonh;
  char regname[11], *s;
  int dumb, nrec, ncnt, i, j, m, nsize;
  long int nls, nbyte;
  float ratio;
  char *space, *store, *store2, *last_store;
  float tbval;
  int count, iadd, end_flag;
  char *x;
  int irecords;
  int non_size_x, non_size_y, nsx2, nsy2, ix, iy;
  float xdeg2, ydeg2, ascale2, bscale2, a02, b02;

  int Nfiles_out=1;  

  int nsx, nsy, iyear, isday, ismin, ieday, iemin;
  int iregion, ipol, iopt;  
  char crproc[101], crtime[29];
  float xdeg, ydeg, ascale, bscale, a0, b0;

  time_t tod;

  int its, irec, keep;
  float amin;

  char a_name[100], info_name[100], line[100];

  cetb_file_class *cetb;
  cetb_swath_producer_id swath_producer_id;
  cetb_platform_id platform_id;
  cetb_sensor_id sensor_id;
  cetb_direction_id direction_id=CETB_NO_DIRECTION;
  unsigned short tb_fill_value=CETB_TB_FILL_VALUE;
  unsigned short tb_missing_value=CETB_TB_MISSING_VALUE;
  unsigned short tb_valid_range[ 2 ] = { CETB_TB_MIN, CETB_TB_MAX };
  int ncerr;

  float tb_fill_value_float;
  float tb_missing_value_float;

  int storage = 0;
  long head_len;
  int errors = 0;

  int median_flag = 0;  /* default: no median filter */
  int ibeam = 0;
 
  int nmax, mdim, mdim2, mwork, k, dx, dy, i1, j1;
  int *ix0, *iy0, *ind, *adds;
  char **indx;
  float sum, *patarr;  
  double **z, **zc, *u, *v, *u1, *v1, *c, *work, *tb2;
  double p, value1, value2;
  int *fill_array;
  short int *weight_array;
  double dsum, *aveweights, tbave;

  tb_fill_value_float = CETB_FILE_UNPACK_DATA( CETB_TB_SCALE_FACTOR,
					       CETB_TB_ADD_OFFSET, tb_fill_value );
  tb_missing_value_float = CETB_FILE_UNPACK_DATA( CETB_TB_SCALE_FACTOR,
						  CETB_TB_ADD_OFFSET, tb_missing_value );
/* begin program */  

  printf("BYU SSM/I meta BG program: C version %f\n",VERSION);

  if (argc < 3) {
    printf("\nusage: %s setup_in outpath gamma delta2 ithres\n\n",argv[0]);
    printf(" input parameters:\n");
    printf("   setup_in = input setup file\n");
    printf("   outpath  = output path\n");
    printf("   gamma    = BGI gamma parameter\n");
    printf("   delta2   = BGI delta2 (noise variance)\n");
    printf("   ithres   = gain threshold (in normal space)\n");
    printf("   difthres = BGI-AVE Q/A threshold\n");
    printf("   mflag    = median filter if 1, do not run if 0, default is 1 for BGI\n");
    return(-1);
  }
  file_in=argv[1];

  imf = fopen(file_in,"r"); 
  if (imf == NULL) {
     eprintfc("ERROR: cannot open input setup file: %s\n",argv[1]); 
     exit(-1);
  }
 
  strcpy(outpath,"./"); /* default output path */  

  if (argc > 2) sscanf(argv[2],"%s",outpath);
  if (argc > 3) sscanf(argv[3],"%lf",&bgi_gamma);
  if (argc > 4) sscanf(argv[4],"%f",&delta2);
  if (argc > 5) sscanf(argv[5],"%f",&ithres);
  if (argc > 6) sscanf(argv[6],"%f",&difthres);
  /* (more later) */

  printf("BGI options: omega=%f gamma=%lf delta2=%f gain thres=%f difthres=%f\n",omega, bgi_gamma, delta2, ithres, difthres);

  /* get input file size */
  fseek(imf, 0L, REL_EOF);
  nls=ftell(imf);
  rewind(imf);

/* read setup file header info 
   note: setup file is written by a fortran program and so has extra
         record information.  This must be skipped when reading */

/*   read (50) irecords  ! Get number of measurement records in file */

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(0); /* record header */
   if (fread(&irecords,sizeof(int)  , 1, imf) == 0) Ferror(1);
   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(2); /* record trailer */

/*   read (50) nsx,nsy,ascale,bscale,a0,b0,xdeg,ydeg ! Get header info */

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(3); /* record header */
   if (fread(&nsx,   sizeof(int)  , 1, imf) == 0) Ferror(4);
   if (fread(&nsy,   sizeof(int)  , 1, imf) == 0) Ferror(5);
   if (fread(&ascale,sizeof(float), 1, imf) == 0) Ferror(6);
   if (fread(&bscale,sizeof(float), 1, imf) == 0) Ferror(7);
   if (fread(&a0,    sizeof(float), 1, imf) == 0) Ferror(8);
   if (fread(&b0,    sizeof(float), 1, imf) == 0) Ferror(9);
   if (fread(&xdeg,  sizeof(float), 1, imf) == 0) Ferror(10);
   if (fread(&ydeg,  sizeof(float), 1, imf) == 0) Ferror(11);

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(12); /* record trailer */

/*        read (50) dstart,dend,mstart,mend,year,regnum,projt,npol,
     $                  latl,lonl,lath,lonh,regname */

   if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(21);
   if (fread(&isday,  sizeof(int),   1, imf) == 0) Ferror(22);
   if (fread(&ieday,  sizeof(int),   1, imf) == 0) Ferror(23);
   if (fread(&ismin,  sizeof(int),   1, imf) == 0) Ferror(24);
   if (fread(&iemin,  sizeof(int),   1, imf) == 0) Ferror(25);
   if (fread(&iyear,  sizeof(int),   1, imf) == 0) Ferror(26);
   if (fread(&iregion,sizeof(int),   1, imf) == 0) Ferror(27);
   if (fread(&iopt ,  sizeof(int),   1, imf) == 0) Ferror(28);
   if (fread(&ipol,   sizeof(int),   1, imf) == 0) Ferror(29);
   if (fread(&latl,   sizeof(float), 1, imf) == 0) Ferror(30);
   if (fread(&lonl,   sizeof(float), 1, imf) == 0) Ferror(31);
   if (fread(&lath,   sizeof(float), 1, imf) == 0) Ferror(32);
   if (fread(&lonh,   sizeof(float), 1, imf) == 0) Ferror(33);
   if (fread(regname, sizeof(char), 10, imf) == 0) Ferror(34);
   regname[10]='\0';
   if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(35);

/*   read (50) nsx2,nsy2,non_size_x,non_size_y,
     $          ascale2,bscale2,a02,b02,xdeg2,ydeg2 */

   if (fread(&dumb,   sizeof(int)  , 1, imf) == 0) Ferror(43);/* record header */
   if (fread(&nsx2,   sizeof(int)  , 1, imf) == 0) Ferror(44);
   if (fread(&nsy2,   sizeof(int)  , 1, imf) == 0) Ferror(45);
   if (fread(&non_size_x,sizeof(int)  , 1, imf) == 0) Ferror(46);
   if (fread(&non_size_y,sizeof(int)  , 1, imf) == 0) Ferror(47);
   if (fread(&ascale2,sizeof(float), 1, imf) == 0) Ferror(48);
   if (fread(&bscale2,sizeof(float), 1, imf) == 0) Ferror(49);
   if (fread(&a02,    sizeof(float), 1, imf) == 0) Ferror(50);
   if (fread(&b02,    sizeof(float), 1, imf) == 0) Ferror(51);
   if (fread(&xdeg2,  sizeof(float), 1, imf) == 0) Ferror(52);
   if (fread(&ydeg2,  sizeof(float), 1, imf) == 0) Ferror(53);

   if (fread(&dumb,   sizeof(int)  , 1, imf) == 0) Ferror(54);/* record trailer */

   /* file header read completed, summarize */
   printf("\nInput file header info: '%s'\n",file_in);
   printf("  Year, day range: %d %d - %d\n",iyear,isday,ieday);
   printf("  Image size: %d x %d = %d   Projection: %d\n",nsx,nsy,nsx*nsy,iopt);
   printf("  Origin: %f,%f  Span: %f,%f\n",a0,b0,xdeg,ydeg);
   printf("  Scales: %f,%f  Pol: %d  Reg: %d\n",ascale,bscale,ipol,iregion);
   printf("  Region: '%s'   Records: %d\n",regname,irecords);
   printf("  Corners: LL %f,%f UR %f,%f\n",latl,lonl,lath,lonh);
   printf("  Grid size: %d x %d = %d  Scales %d %d\n",nsx2,nsy2,nsx2*nsy2,non_size_x,non_size_y);
   printf("  Grid Origin: %f,%f  Grid Span: %f,%f\n",a02,b02,xdeg2,ydeg2);
   printf("  Grid Scales: %f,%f\n",ascale2,bscale2);
   printf("\n");
   fflush(stdout);

   /* read output file names and misc variables

     In principle, these can be in variable order.  However, if standard
     program is used, order and number is known.  Most variables are info
     only, but some control the internal operations.
   */

   end_flag = 0;
   do {
     
     if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(70);
     if (fread(line,   sizeof(char), 100, imf) == 0) Ferror(71);
     if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(72);

     if (strstr(line,"A_initialization") != NULL) {
       x = strchr(line,'=');
       a_init=  atof(++x) ;
     }

     if (strstr(line,"Beam_code") != NULL) {
       x = strchr(line,'=');
       ibeam=atoi(++x);
       printf("Beam code %d\n",ibeam);
     }

     if (strstr(line,"Max_Fill") != NULL) {
       x = strchr(line,'=');
       MAXFILL=atoi(++x);
     }

     if ( strstr( line, " Producer_id" ) != NULL ) {
       x = strchr( line,'=' );
       swath_producer_id = ( cetb_swath_producer_id )atoi(++x);
       printf( "Producer_id %s\n", cetb_swath_producer_id_name[ swath_producer_id ] );
     }

     if ( strstr( line, " Platform_id" ) != NULL ) {
       x = strchr( line,'=' );
       platform_id = ( cetb_platform_id )atoi(++x);
       printf( "Platform_id %s\n", cetb_platform_id_name[ platform_id ] );
     }

     if ( strstr( line, " Sensor_id" ) != NULL ) {
       x = strchr( line,'=' );
       sensor_id = ( cetb_sensor_id )atoi(++x);
       printf( "Sensor_id %s\n", cetb_sensor_id_name[ sensor_id ] );
     }

     if ( strstr( line, " Pass_direction" ) != NULL ) {
       x = strchr( line,'=' );
       direction_id = ( cetb_direction_id )atoi(++x);
       printf( "Direction_id %s\n", cetb_direction_id_name[ direction_id ] );
     }


     if (strstr(line,"Response_Multiplier") != NULL) {
       x = strchr(line,'=');
       printf("Wscale %f\n",wscale);
     }

     if (strstr(line,"Sensor") != NULL) {
       x = strchr(line,'=');
       strncpy(sensor_in,++x,40);
       no_trailing_blanks(sensor_in);
       printf("Sensor '%s'\n",sensor_in);
     }

     if ((x = strchr(line+4,' ')) != NULL) *x='\0'; /* truncate off any trailing spaces */

     if (strstr(line,"Has_Azimuth_Angle") != NULL) {
       x = strchr(line,'=')+1;
       if (strstr(x,"T") != NULL || strstr(x,"t") != NULL) {
	 HASAZANG=1;
	 HS += 4;  /* increase read buffer size */
       }
       if (strstr(x,"F") != NULL || strstr(x,"f") != NULL)
	 HASAZANG=0;
       printf("Has azimuth angle: %d\n",HASAZANG);       
     }

     if (strstr(line,"SIRF_A_file") != NULL) {
       x = strchr(line,'=');
       strncpy(a_name,++x,100);
       no_trailing_blanks(a_name);
     }
     if (strstr(line,"Info_file") != NULL) {
       x = strchr(line,'=');
       strncpy(info_name,++x,100);
       no_trailing_blanks(info_name);
     }
      
     if (strstr(line,"End_header") != NULL) {
       end_flag = 1;
     }

   } while (end_flag == 0);

   /* optionally override median filter flag */
   median_flag = 1;
   i=-1;   
   if (argc > 7) sscanf(argv[7],"%d",&i);
   if (i==1) median_flag=1;   
   if (i==0) median_flag=0;
   printf("Median flag: %d\n",median_flag);

   printf("\n");
   printf("A output file: '%s'\n",a_name);
   printf("Info file: '%s'\n",info_name);
   printf("\n");

   /*
    * Initialize cetb_file.
    */
   cetb = cetb_file_init( outpath,
			  iregion, ascale, platform_id, sensor_id,
			  iyear, isday, ibeam,
			  direction_id,
			  CETB_BGI,
			  swath_producer_id );
   if ( !cetb ) {
     fprintf( stderr, "%s: Error initializing cetb_file.\n", __FUNCTION__ );
     exit( -1 );
   }

   if ( 0 != cetb_file_open( cetb ) ) {
     fprintf( stderr, "%s: Error opening cetb_file=%s.\n", __FUNCTION__, cetb->filename );
     exit( -1 );
   }
     
   head_len = ftell(imf);
   printf("Input header file length %ld\n",head_len);
   nls=nls-head_len;

   fflush(stdout);

/* header read completed, now determine how much program memory to allocate */

  nspace = nls * file_savings;/* space to allocate for measurement storage */
  printf("  File size: %ld  Space allocated: %ld\n",nls,nspace);
  /*  space = (char *) malloc(sizeof(char)*nspace); */
  dumb = posix_memalign( (void**)&space, CETB_MEM_ALIGNMENT, nspace * sizeof(char) );
  if (dumb != 0) {
      eprintf("*** Inadequate memory for data file storage\n");
      exit(-1);
  }

/* allocate storage space for image and working array */

  nsize = nsx * nsy;
  
  //  a_val  = (float *) malloc(sizeof(float)*nsize);
  dumb = posix_memalign( (void**)&a_val, CETB_MEM_ALIGNMENT, nsize*sizeof(float) );
  if (dumb != 0) {
    eprintf("*** Inadequate memory for data file storage\n");
    exit(-1);
  }

  dumb = posix_memalign( (void**)&a_temp, CETB_MEM_ALIGNMENT, nsize*sizeof(float) );
  if (dumb != 0) {
    eprintf("*** Inadequate memory for data file storage\n");
    exit(-1);
  }
  
  dumb = posix_memalign( (void**)&cnts, CETB_MEM_ALIGNMENT, nsize*sizeof(float) );
  if (dumb != 0) {
    eprintf("*** Inadequate memory for data file storage\n");
    exit(-1);
  }
  
   fflush(stdout);  

   /* initialize count array */

   for (i=0; i < nsize; i++)
     cnts[i]=0;
   mwork=0;

  /* with storage allocated, copy file into memory  */

  /* read measurement file into memory, 
			   storing only essential information  */

  nrec = 0;         /* number of meaurements in file */
  ncnt = 0;         /* number of useable measurements */
  nbyte = 0;        /* file size in bytes */
  store=space;      /* storage pointer */
  
  printf("Begin setup file copy into memory\n");
  while (fread(&dumb, sizeof(int), 1, imf) != 0) {

     /*5 items at 4 bytes each: 20 bytes if no azimuth angle */
     /*6 items at 4 bytes each: 24 bytes if azimuth angle */
     if (nbyte+HS < nspace) {
       	if ((dumb=fread(store, sizeof(char), HS, imf)) != HS) {
          eprintfi(" *** Error reading input file data at 180 %d\n",dumb);
	  exit(-1);
        }
        if (fread(&dumb,sizeof(int), 1, imf) == 0) Ferror(100);

        tbval = *((float *) (store+0));
        /* ang   = *((float *) (store+4));  */
        count = *((int *)   (store+8));
        iadd  = *((int *)   (store+16));

	if (count > MAXFILL) {
	  printf("*** Count error %d  record %d\n",count,nrec);
	  count=MAXFILL;	  
	}

	keep=0;
	if (tbval < CETB_TB_SCALED_MAX && tbval > CETB_TB_SCALED_MIN) { 
	  nbyte=nbyte+HS;
	  store=store+HS;
	  ncnt++;
	  keep=1;
	}

	/* read fill_array pixel indices */
	if (nbyte+count*4 < nspace) {
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(110);
	   if (fread(store, sizeof(int), count, imf) != count) {
	      eprintf(" *** Error reading input file data at 111\n");
	      goto label;
	   }

	   if (keep == 1) {
	     last_store=store;
	     nbyte=nbyte+count*4;
	     store=store+count*4;
	   }
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(112);
	} else {
	   eprintfi(" *** out of storage space 1 *** %d\n",ncnt);
	   fprintf(stderr," *** out of storage space 1 *** %d %ld %ld\n",ncnt,nbyte,nspace);
	   exit(-1);
	}

	/* read response_array weights */
	if (nbyte+count*2 < nspace) {
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(1101);
	   if (fread(store, sizeof(short int), count, imf) != count) {
	      eprintf(" *** Error reading input file data at 1111\n");
	      goto label;
	   }
	   if (keep == 1) {
	     count_hits(count, (int *) last_store, (short int *) store, ithres, cnts, &m, nsx);
	     if (m > mwork) mwork = m;
	     if (count % 2 == 1) count=count+1;  /* ensure storage of next record on a 4byte word boundary */
	     nbyte=nbyte+count*2;
	     store=store+count*2;
	   }
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(1121);
	} else {
	   eprintfi(" *** out of storage space 2 *** %d\n",ncnt);
	   fprintf(stderr," *** out of storage space 2 *** %d %ld %ld\n",ncnt,nbyte,nspace);
	   exit(-1);
	}

	nrec++;

     } else {
       eprintfi(" *** out of storage space 3 *** %d\n",ncnt);
       fprintf(stderr," *** out of storage space 3 *** %d %ld\n",ncnt,nspace);
       exit(-1);
     }
    }
  label:
  fclose(imf);

/* print measurement file storage requirements */

  ratio=100.0 * (float) nbyte / (float) nls;
  printf("  Input file read into ram\n");
  printf("  Total storage used: %d %d recs = %ld of %ld (%.1f%% %.1f%%)\n",
	 nrec,ncnt,nbyte,nspace,ratio,100.0*file_savings);
  fflush(stdout);

  /* determine maximum hits */

  nmax=0;
  for (i=0; i< nsize; i++)
    if (cnts[i] > nmax) nmax=cnts[i];
  printf("\nMaximum hits above threshold: %d  max size: %d  thres %f\n",nmax, mwork, ithres);
  mdim = mwork * 2+1;
 
  /* BG processing */

  /* allocate index array and BGI working arrays*/

  dumb = posix_memalign( (void**)&indx, CETB_MEM_ALIGNMENT, nsize*nmax*sizeof(char *) );
  if (dumb != 0) {
    eprintf("*** Inadequate memory for data file storage\n");
    exit(-1);
  }
  z = dmatrix(1,nmax,1,nmax);
  zc = dmatrix(1,nmax,1,nmax);
  u = dvector(1,nmax);
  u1 = dvector(1,nmax);
  v = dvector(1,nmax); 
  aveweights = dvector(1,nmax); 
  v1 = dvector(1,nmax); 
  ind = ivector(1,nmax);
  adds = ivector(1,nmax);  
  work = dvector(1,nmax);
  c = dvector(1,nmax);
  tb2 = dvector(1,nmax);

  dumb = posix_memalign( (void **)&patarr, CETB_MEM_ALIGNMENT, mdim*mdim*nmax*sizeof(float) );
  if (dumb != 0) {
    eprintf("*** Inadequate memory for data file storage, patarr\n");
    exit(-1);
  }

  dumb = posix_memalign( (void **)&ix0, CETB_MEM_ALIGNMENT, (nmax+1)*sizeof(int) );
  if (dumb != 0) {
    eprintf("*** Inadequate memory for data file storage, ix0\n");
    exit(-1);
  }

  dumb = posix_memalign( (void **)&iy0, CETB_MEM_ALIGNMENT, (nmax+1)*sizeof(int) );
  if (dumb != 0) {
    eprintf("*** Inadequate memory for data file storage, iy0\n");
    exit(-1);
  }

  if (indx == NULL || z == NULL || zc == NULL || u == NULL
      || u1 == NULL || v == NULL || aveweights == NULL || v1 == NULL
      || ind == NULL || adds == NULL || work == NULL || c == NULL
      || tb2 == NULL || patarr == NULL || ix0 == NULL || iy0 == NULL) {
    printf("*** error allocating BGI work arrays \n");
    exit(-1);
  }

  /* initialize SRF storage array */
  for (i=0; i<mdim*mdim*nmax; i++)
    patarr[i]=0.0;  

  /* create index array */

  for (i=0; i< nsize; i++)
    for (j=0; j< nmax; j++)
      indx[i*nmax+j] = NULL;

  store=space;
  for (irec = 0; irec < ncnt; irec++) {
    last_store=store;
    count = *((int *)   (store+8));
    iadd = *((int *) (store+16));
    store = store+HS;
    store2 = store + 4*count;
  
    make_indx(nmax, count, (int *) store, (short int *) store2, ithres, indx, last_store);
    store = store+4*count;
    store = store+2*count;
    if (count % 2 == 1) store=store+2;  /* ensure word boundary */
  }

  printf("Index array created %d %d\n",nsize,ncnt);
  
/* Begin BGI processing */

  mdim2=mdim/2+1;

  for (its=0; its < nsize; its++) {   /* for each pixel */
    *(a_val+its) = tb_fill_value_float;

    /* print progress */
    if ((its % nsx) == nsx/2  && (its/nsx) % 50 == 0) {
      printf("Processing row %d of %d  %f\n",its/nsx,nsy,amin);
      fflush( stdout );
    }
    
    if (cnts[its] > 0) {
      m=0;  /* number of valid measurements */
      for (k=0; k < nmax; k++) {  /* for possible each measurement */
	store = indx[its*nmax + k];
	if (store != NULL) {        /* get measurement info from memory */
	  tbval = *((float *) (store+0));
	  count = *((int *)   (store+8));
	  iadd  = *((int *)  (store+16));
	  iadd = (iadd > 0 ? iadd : -iadd) -1;

	  store = store+HS;
	  fill_array = (int *) store;
	  store = store + 4*count;
	  weight_array = (short int *) store;
	  m++;
	  v[m] = 0.0000001;  /* a very small, non-zero value */
	  dsum = 0.0;
	  for (i=0; i < count; i++) 
	    if (fill_array[i]>0) {
	      if (fill_array[i]-1 == its) {
		v[m] = weight_array[i]*wscale;
		aveweights[m] = weight_array[i]*wscale;
	      }
	      dsum += weight_array[i]*wscale;
	    }
	  tb2[m] = tbval;
	  if (dsum > 0.0) v[m]=v[m]/dsum;
	  u[m]=1.0;
	  adds[m] = iadd;
	
	  ix0[m] = iadd % nsx;
	  iy0[m] = iadd / nsx;

	  for (i=0; i < mdim*mdim; i++)
	    patarr2d(i,m)=0.0;
	
	  for (i=0; i < count; i++) 
	    if (fill_array[i]>0) {
	      dx = (fill_array[i]-1) % nsx - ix0[m];
	      if (dx < -nsx/2) dx=dx+nsx; /* handle measurements that span horizontal image edge */
	      if (dx >  nsx/2) dx=dx-nsx; /* handle measurements that span horizontal image edge */
	      ix = dx + mdim2;
	      iy = (fill_array[i]-1) / nsx - iy0[m] + mdim2;
	      if (ix >= 0 && iy >= 0 && ix < mdim && iy < mdim)
		patarr3d(ix,iy,m) = weight_array[i]*wscale;
	      else
		printf("*** patarr error %d %d %d  %d\n",i,ix,iy,its);
	    }
	}
      }

      if (m > 0) {  /* measurements are available for this pixel */

	/* compute AVE estimate */
	dsum = 0.0;	
	tbave = 0.0;  
	for (i=1; i <= m; i++) {
	  dsum = dsum + aveweights[i];
	  tbave = tbave + aveweights[i] * tb2[i];
	}
        tbave = tbave / dsum; /* AVE Tb estimate */

	/* check for measurements at the same (quantized) center location and average */
	dx=0;
	for (i=1; i <= m; i++) {
	  for (j=i+1; j <= m; j++) {
	    if (adds[i]==adds[j]) dx++;
	  }
	}
	if (dx > 0) { /* duplicated location measurement(s) */
	  dx = 0;
	  for (i=1; i <= m; i++) {
	    if (adds[i] > -1) {
	      dx++;
	      dy = 0;
	      for (j=i+1; j <= m; j++) {
		if (adds[i]==adds[j]) {  /* average in redundant meaurement */
		  dy++;
		  v[dx]=(v[dx]*(dy-1)+v[j])/(float) dy;       
		  tb2[dx]=(tb2[dx]*(dy-1)+tb2[j])/(float) dy; 
		  for (ix=0; ix<mdim*mdim; ix++)
		    patarr2d(ix,dx)=(patarr2d(ix,dx)*(dy-1)+patarr2d(ix,j))/(float) dy;
		  adds[j]=-1;
		}
	      }
	    }
	  }
	  /* re-organize to remove redundant entries */
	  dx = 0;
	  for (i=1; i <= m; i++)
	    if (adds[i] > -1) {
	      dx++;
	      if (dx != i) {		  
		v[dx]=v[i];
		tb2[dx]=tb2[i];
		ix0[dx]=ix0[i]; 
		iy0[dx]=iy0[i]; 
		for (ix=0; ix<mdim*mdim; ix++)
		  patarr2d(ix,dx)=patarr2d(ix,i);
	      }	      
	    }
	  m=dx;  /* reset number of unique location measurements */
	}

	/* compute z matrix */
	for (i=1; i <= m; i++)
	  for (j=i; j <= m; j++) {
	    dx = ix0[i] - ix0[j];
	    dy = iy0[i] - iy0[j];
	    z[i][j] = 0.0;
	    dsum=0.0;
	    for (j1=1; j1 <= mdim; j1++)
	      for (i1=1; i1 <= mdim; i1++) {
		ix=i1-dx;
		iy=j1-dy;
		if (ix > 0 && iy > 0 && ix <= mdim && iy <= mdim)
		  dsum = dsum + patarr3d(i1,j1,i)*patarr3d(ix,iy,j);
	      } 
	    z[i][j] = dsum * cos(bgi_gamma);
	    if (i == j) 
	      z[i][j] =  z[i][j] + omega * sin(bgi_gamma) * delta2;
	    else
	      z[j][i] = z[i][j];
	  }

	/* Do LU decomposition */
	dludcmp(z,m,ind,&p);

	for (i=1;i<=m;i++) {
	  u1[i]=u[i];
	  v1[i]=v[i];
	  for (j=1;j<=m;j++)
	    zc[i][j] = z[i][j];
	}
      
      /* solve linear system z x = u [compute z^-1 u]  (u and z destroyed in process) */
	dlubksb(z,m,ind,u1);

      /* comute u^t z^-1 u */
	value2 = 0.0;
	for (i=1; i <= m; i++)
	  value2 = value2 + u[i] * u1[i];

	for (i=1;i<=m;i++)
	  for (j=1;j<=m;j++)
	    z[i][j] = zc[i][j];

      /* solve linear system z x = v [compute z^-1 v]  (v and z destroyed in process) */
	dlubksb(z,m,ind,v1);

      /* comute u^t z^-1 v */
	value1 = 0.0;
	for (i=1; i <= m; i++)
	  value1 = value1 + u[i] * v1[i];

      /* compute work vector */
	for (i=1; i <= m; i++)
	  work[i] =  cos(bgi_gamma) *v[i] + u[i] * (1.0 - cos(bgi_gamma)  * value1)/value2;
      
      /* solve linear system z c = work [compute z^-1 work]  (destroyed in process) */
	dlubksb(zc,m,ind,work);
      
      /* compute BG pixel estimate value */
	dsum = 0.0;
	for (i=1; i <= m; i++)
	  dsum = dsum + work[i] * tb2[i];
	a_val[its] = (float) dsum;
	
	amin=a_val[its];

      /* simple Q/A test and replace for bad BGI estimates */
        if (abs(a_val[its] - tbave) > difthres)
	  a_val[its]=(float) tbave;	

      /* set data to CETB_TB_MISSING_VALUE if it is OOR */
       	if ( a_val[its] < CETB_TB_SCALED_MIN || a_val[its] > CETB_TB_SCALED_MAX ) {
	  a_val[its] = tb_missing_value_float;
	}
	
      } else /* pixel not hit, set its value to the default nodata value */
	a_val[its] = tb_fill_value_float;
    } 
  }

  printf("\nMaximum hits above threshold: %d  max size: %d  thres %f\n",nmax,mdim, ithres);

  if (median_flag) { /* median filter image */
    printf("Applying Median Filter to BG image result\n");    
    filter(a_val, 3, 0, nsx, nsy, a_temp, tb_fill_value_float, tb_missing_value_float);  /* 3x3 modified median filter */
  }

  /* output image file */
  printf("\n"); 
  if ( 0 != cetb_file_add_var( cetb, "TB", NC_USHORT, a_val,
			       ( size_t )nsx, ( size_t ) nsy,
			       CETB_FILE_TB_STANDARD_NAME,
			       "BGI TB",
			       CETB_FILE_TB_UNIT,
			       &tb_fill_value,
			       &tb_missing_value,
			       &tb_valid_range,
			       CETB_PACK,
			       (float) CETB_TB_SCALE_FACTOR,
			       (float) CETB_TB_ADD_OFFSET,
			       NULL ) ) {
    errors++;
    fprintf( stderr, "%s: Error writing Tb (A).\n", __FILE__ );
  } else {
    fprintf( stderr, "> %s: Wrote Tb (A) to %s.\n", __FILE__, cetb->filename );
  }
    
  if ( 0 != cetb_file_add_bgi_parameters( cetb, bgi_gamma, omega, delta2,
					  ithres, difthres, median_flag ) ) {
    fprintf( stderr, "%s: Error adding BGI parameters to %s.\n", __FUNCTION__, cetb->filename );
    exit( -1 );
  }
  cetb_file_close( cetb );

  if (errors == 0) {
    printf("No errors encountered\n");
  } else {
    printf("Processing errors encountered\n");
  }
  
  /* end of program */

  /* free malloc'ed memory (not strictly necessary, but good to be explicit) */
  free(space);
  free(a_val);
  free(a_temp);

  return(errors);
}


/* ***************** support routines **************** */

void count_hits(int count, int fill_array[], short int response_array[], float ithres, int cnt[], int *mdim, int nsx)
{
  register int i,n,m,x,y,xx,yx,xn,yn;
  int mpeak=-1;  

  /* find peak response of measurement*/
  for (i=0; i < count; i++) {      
    m=response_array[i];
    if (m > mpeak) mpeak=m;
  }
  /* compute (local) threshold based on peak response */
  mpeak=ithres*mpeak;

  /* find minimum size bounding box */
  yx=xx=0;
  yn=xn=99999999;
  for (i=0; i < count; i++) {
    n=fill_array[i]-1;
    m=response_array[i];
    if (m >= mpeak) {
      (cnt[n])++;
      x = n % nsx;
      y = n / nsx;
      xx = max(x,xx);
      yx = max(y,yx);
      xn = min(x,xn);
      yn = min(y,yn);
    } else { /* mark response values not to be used since they are below cutoff threshold */
      fill_array[i]=0;
      response_array[i]=0.0;      
    }
  }
  if (xx-xn+1 < nsx/2) /* check horizontal measurement span */
    x=xx-xn+1; /* horizontal span */
  else
    x=0;      /* do not consider horiznotal span of measurements that cross horizontal boundaries */
  y=yx-yn+1;  /* vertical span */
  *mdim=max(x,y);
}

void make_indx(int nmax, int count, int fill_array[], short int response_array[], float ithres, char **indx, char *pointer)
{
  static int i,j,m,n,mpeak=-1;

  /* find peak response of measurement*/
  for (i=0; i < count; i++)
    if (fill_array[i] > 0) {
      m=response_array[i];
      if (m > mpeak) mpeak=m;
    }
  /* compute (local) threshold based on peak response */
  mpeak=ithres*mpeak;

  for (i=0; i < count; i++) 
    if (fill_array[i] > 0) {
      n=fill_array[i]-1;
      m=response_array[i];
      if (m >= ithres) {
	j = 0;
	while (j < nmax && indx[n*nmax+j] != NULL) j++;
	if (j < nmax) indx[n*nmax+j]=pointer;
      }
    }  
}

/* modified median or smoothing filter routine */

float median(float *array, int count);

void filter(float *val, int size, int mode, int nsx, int nsy, 
	    float *temp, float thres, float missing)
{
  float array[100], total;
  int i,j,x,y,size2,count,x1,x2,y1,y2;
  
  if ((size % 2) == 0) size=size+1;   /* force window size odd */
  size2 = (size-1)/2;                 /* window center */

  for (x=1; x<= nsx; x++)
    for (y=1; y<= nsy; y++) {
      count=0;
      y1=max(y-size2,1);
      y2=min(y+size2,nsy);
      x1=max(x-size2,1);
      x2=min(x+size2,nsx);
      for (i=x1; i <= x2; i++)
	for (j=y1; j <= y2; j++)
	  if ( (*(val+i+(j-1)*nsx-1) > thres) && (*(val+i+(j-1)*nsx-1) < missing) ) {
	    array[count]=*(val+i+(j-1)*nsx-1);
	    count++;
	  };
      
      if (count > 0 && *(val+x+(y-1)*nsx-1) > thres) {
	if (mode == 0)  /* Mode 0 = median */
	  *(temp+(y-1)*nsx+x-1) = median(array,count);
	else {		/* Mode 1 = average */
	  total=0.0;
	  for (i=0; i<count; i++)
	    total=total+array[i];
	  *(temp+(y-1)*nsx+x-1) = total/count;
	}
      } else
	*(temp+(y-1)*nsx+x-1) = thres;
    };
  
  for (i=0; i < nsx*nsy; i++) {
    *(val+i) = *(temp+i);
    *(temp+i)=0.0;
    if ( (*(val+i) > thres) && ( (*(val+i) < CETB_TB_SCALED_MIN) || (*(val+i) > CETB_TB_SCALED_MAX) ) ) *(val+i) = missing;
  }
  return;
}

/* compute modified median of an array of values */

float median(float array[], int count)
{
  int i,j;
  float temp;

  for (i=count; i >= 2; i--)
    for (j=1; j <= i-1; j++)
      if (array[i-1] < array[i-j-1]) {
	temp=array[i-1];
	array[i-1]=array[i-j-1];
	array[i-j-1]=temp;
      };
  
  temp=array[count/2];

  if (array[count-2]-array[1] < 0.25 && count > 5) {
    temp=0.0;
    for (i=count/2-1; i <= count/2+3; i++)
      temp=temp+array[i-1];
    temp=temp/5.0;
  }
  return(temp);
}

void Ferror(int i)
{
  fprintf(stdout,"*** Error reading input file at %d ***\n",i);
  fprintf(stderr,"*** Error reading input file at %d ***\n",i);
  fflush(stdout);
  fflush(stderr);
  return;
}

void no_trailing_blanks(char *s)
{  /* remove trailing blanks (spaces) from string */
  int n=strlen(s);
  
  while (n > 0) {
    if (s[n] != ' ' && s[n] != '\0') return;
    if (s[n] == ' ') s[n] = '\0';
    n--;
  }
  return;
}

char *addpath(char *outpath, char *name, char *temp)
{ /* append path to name, return pointer to temp */
  sprintf(temp,"%s/%s",outpath,name);
  return(temp);  
}

/****************************************************************************/

/* Numerical Recipes routines */

void dlubksb(double **a, int n, int *indx, double b[])
{
	int i,ii=0,ip,j;
	double sum;

	for (i=1;i<=n;i++) {
		ip=indx[i];
		sum=b[ip];
		b[ip]=b[i];
		if (ii)
			for (j=ii;j<=i-1;j++) sum -= a[i][j]*b[j];
		else if (sum) ii=i;
		b[i]=sum;
	}
	for (i=n;i>=1;i--) {
		sum=b[i];
		for (j=i+1;j<=n;j++) sum -= a[i][j]*b[j];
		b[i]=sum/a[i][i];
	}
}

#define TINY 1.0e-20;

void dludcmp(double **a, int n, int *indx, double *d)
{
	int i,imax,j,k;
	double big,dum,sum,temp;
	double *vv;

	vv=dvector(1,n);
	*d=1.0;
	for (i=1;i<=n;i++) {
		big=0.0;
		for (j=1;j<=n;j++)
			if ((temp=fabs(a[i][j])) > big) big=temp;
		if (big == 0.0) nrerror("Singular matrix in routine ludcmp");
		vv[i]=1.0/big;
	}
	for (j=1;j<=n;j++) {
		for (i=1;i<j;i++) {
			sum=a[i][j];
			for (k=1;k<i;k++) sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
		}
		big=0.0;
		for (i=j;i<=n;i++) {
			sum=a[i][j];
			for (k=1;k<j;k++)
				sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
			if ( (dum=vv[i]*fabs(sum)) >= big) {
				big=dum;
				imax=i;
			}
		}
		if (j != imax) {
			for (k=1;k<=n;k++) {
				dum=a[imax][k];
				a[imax][k]=a[j][k];
				a[j][k]=dum;
			}
			*d = -(*d);
			vv[imax]=vv[j];
		}
		indx[j]=imax;
		if (a[j][j] == 0.0) a[j][j]=TINY;
		if (j != n) {
			dum=1.0/(a[j][j]);
			for (i=j+1;i<=n;i++) a[i][j] *= dum;
		}
	}
	free_dvector(vv,1,n);
}
#undef TINY

/* CAUTION: This is the ANSI C (only) version of the Numerical Recipes
   utility file nrutil.c.  Do not confuse this file with the same-named
   file nrutil.c that is supplied in the 'misc' subdirectory.
   *That* file is the one from the book, and contains both ANSI and
   traditional K&R versions, along with #ifdef macros to select the
   correct version.  *This* file contains only ANSI C.               */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#define NR_END 1
#define FREE_ARG char*

void nrerror(char error_text[])
/* Numerical Recipes standard error handler */
{
	fprintf(stderr,"Numerical Recipes run-time error...\n");
	fprintf(stderr,"%s\n",error_text);
	fprintf(stderr,"...now exiting to system...\n");
	exit(1);
}

float *vector(long nl, long nh)
/* allocate a float vector with subscript range v[nl..nh] */
{
	float *v;

	v=(float *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(float)));
	if (!v) nrerror("allocation failure in vector()");
	return v-nl+NR_END;
}

int *ivector(long nl, long nh)
/* allocate an int vector with subscript range v[nl..nh] */
{
	int *v;

	v=(int *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(int)));
	if (!v) nrerror("allocation failure in ivector()");
	return v-nl+NR_END;
}

unsigned char *cvector(long nl, long nh)
/* allocate an unsigned char vector with subscript range v[nl..nh] */
{
	unsigned char *v;

	v=(unsigned char *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(unsigned char)));
	if (!v) nrerror("allocation failure in cvector()");
	return v-nl+NR_END;
}

unsigned long *lvector(long nl, long nh)
/* allocate an unsigned long vector with subscript range v[nl..nh] */
{
	unsigned long *v;

	v=(unsigned long *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(long)));
	if (!v) nrerror("allocation failure in lvector()");
	return v-nl+NR_END;
}

double *dvector(long nl, long nh)
/* allocate a double vector with subscript range v[nl..nh] */
{
	double *v;

	v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));
	if (!v) nrerror("allocation failure in dvector()");
	return v-nl+NR_END;
}

float **matrix(long nrl, long nrh, long ncl, long nch)
/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	float **m;

	/* allocate pointers to rows */
	m=(float **) malloc((size_t)((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;

	/* allocate rows and set pointers to them */
	m[nrl]=(float *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

double **dmatrix(long nrl, long nrh, long ncl, long nch)
/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	double **m;

	/* allocate pointers to rows */
	m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;

	/* allocate rows and set pointers to them */
	m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

int **imatrix(long nrl, long nrh, long ncl, long nch)
/* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	int **m;

	/* allocate pointers to rows */
	m=(int **) malloc((size_t)((nrow+NR_END)*sizeof(int*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;


	/* allocate rows and set pointers to them */
	m[nrl]=(int *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(int)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

float **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,
	long newrl, long newcl)
/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */
{
	long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;
	float **m;

	/* allocate array of pointers to rows */
	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure in submatrix()");
	m += NR_END;
	m -= newrl;

	/* set pointers to rows */
	for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

float **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch)
/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
and ncol=nch-ncl+1. The routine should be called with the address
&a[0][0] as the first argument. */
{
	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;
	float **m;

	/* allocate pointers to rows */
	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure in convert_matrix()");
	m += NR_END;
	m -= nrl;

	/* set pointers to rows */
	m[nrl]=a-ncl;
	for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;
	/* return pointer to array of pointers to rows */
	return m;
}

float ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh)
/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */
{
	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;
	float ***t;

	/* allocate pointers to pointers to rows */
	t=(float ***) malloc((size_t)((nrow+NR_END)*sizeof(float**)));
	if (!t) nrerror("allocation failure 1 in f3tensor()");
	t += NR_END;
	t -= nrl;

	/* allocate pointers to rows and set pointers to them */
	t[nrl]=(float **) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float*)));
	if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");
	t[nrl] += NR_END;
	t[nrl] -= ncl;

	/* allocate rows and set pointers to them */
	t[nrl][ncl]=(float *) malloc((size_t)((nrow*ncol*ndep+NR_END)*sizeof(float)));
	if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");
	t[nrl][ncl] += NR_END;
	t[nrl][ncl] -= ndl;

	for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;
	for(i=nrl+1;i<=nrh;i++) {
		t[i]=t[i-1]+ncol;
		t[i][ncl]=t[i-1][ncl]+ncol*ndep;
		for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;
	}

	/* return pointer to array of pointers to rows */
	return t;
}

void free_vector(float *v, long nl, long nh)
/* free a float vector allocated with vector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_ivector(int *v, long nl, long nh)
/* free an int vector allocated with ivector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_cvector(unsigned char *v, long nl, long nh)
/* free an unsigned char vector allocated with cvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_lvector(unsigned long *v, long nl, long nh)
/* free an unsigned long vector allocated with lvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_dvector(double *v, long nl, long nh)
/* free a double vector allocated with dvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_matrix(float **m, long nrl, long nrh, long ncl, long nch)
/* free a float matrix allocated by matrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch)
/* free a double matrix allocated by dmatrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_imatrix(int **m, long nrl, long nrh, long ncl, long nch)
/* free an int matrix allocated by imatrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_submatrix(float **b, long nrl, long nrh, long ncl, long nch)
/* free a submatrix allocated by submatrix() */
{
	free((FREE_ARG) (b+nrl-NR_END));
}

void free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch)
/* free a matrix allocated by convert_matrix() */
{
	free((FREE_ARG) (b+nrl-NR_END));
}

void free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,
	long ndl, long ndh)
/* free a float f3tensor allocated by f3tensor() */
{
	free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));
	free((FREE_ARG) (t[nrl]+ncl-NR_END));
	free((FREE_ARG) (t+nrl-NR_END));
}

