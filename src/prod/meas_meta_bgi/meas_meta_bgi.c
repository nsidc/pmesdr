/* (c) copyright 2014 David G. Long, Brigham Young University */
/*****************************************************************
  Filename:  meas_meta_bgi.c    MEaSURES project

  program to generate Backus-Gilbert Inversion (bgi) images from
  setup files generated by the ssmi_meta_setup program

  Written by DGL at BYU 02/25/2014 + modified from ssmi_meta_bgi.c

******************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>

#include "sir3.h"

#define NRANSI
#include "nr.h"
#include "nrutil.h"

#define VERSION 0.2

//#define M_PI 3.14159265358979323846264338327  //already in math.h
#define DTR M_PI/180.0  /* degree to radian multiple */
#define RTD 180.0/M_PI  /* radian to degree multiple */

#define file_savings 1.00     /* measurement file savings ratio */
#define REL_EOF   2           /* fseek relative to end of file */

#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))
#define rnd(a) ((a) >= 0 ? floor((a)+0.5L) : ceil((a)-0.5L))

/****************************************************************************/

/* some variables and their default values */

float a_init=180.0;           /* initial A (TB) value */
int   nits=30;                /* number of SIR iterations */
char  sensor_in[40];          /* sensor description string */
int   MAXFILL=1000;           /* maximum number of pixels in response */
int   HASAZANG=0;             /* azimuth angle data not included */
int   HS=20;                  /* measurement headersize in bytes */

/* the following BG parameters are subjectively set */

double bgi_gamma=0.01*3.141562654;/* BGI gamma parameter */
float delta2=1.0;                 /* BGI assumed noise variance */
float omega=0.001;                /* BGI scale factor */
short int ithres=0;               /* minimum gain threshold */
int Nsize=0;                      /* (built into the code) */
float wscale=0.001;  /* pattern coversion factor int->float */

/****************************************************************************/

void eprintf(char *s)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s);
  fflush(stdout);
  fprintf(stderr,s);
  fflush(stderr);
}

void eprintfi(char *s, int a)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s,a);
  fflush(stdout);
  fprintf(stderr,s,a);
  fflush(stderr);
}
void eprintfc(char *s, char *a)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s,a);
  fflush(stdout);
  fprintf(stderr,s,a);
  fflush(stderr);
}


/* function prototypes */

void count_hits(int count, int fill_array[], short int response_array[], short int ithres, int cnt[], int *mdim, int nsx);

void make_indx(int nmax, int count, int fill_array[], short int response_array[], short int ithres, char **indx, char * pointer);

void Ferror(int i);

int get_measurements(char *store, char *store2, float *tbval, float *ang, int *count,
		     int *ktime, int *iadd, int *nrec);

void time_updates(float tbval, float ktime, float ant, int count,
		  int *fill_array, short int *response_array);

void stat_updates(float tbval, float ang, int count, int *fill_array,
		  short int *response_array);

void filter(float *val, int size, int opt, int nsx, int nsy, float
	    *temp, float thres);

void no_trailing_blanks(char *s);

char *addpath(char *outpath, char *name, char *temp);

/****************************************************************************/

/* global array variables used for storing images*/

float *a_val, *b_val, *a_temp, *sxy, *sx, *sx2, *sy, *tot;
int *cnts;

/* other global variables */

FILE *imf, *omf;
long int nspace;

/****************************************************************************/

/* main program */

int main(int argc, char **argv)
{

  char *file_in;
  char outpath[150], tstr[350];

  float latl, lonl, lath, lonh;
  char regname[11], *s;
  int dumb, nrec, ncnt, i, j, n, m, ii, iii, nsize;
  long int nls, nbyte;
  float ratio;
  char *space, *store, *store2, *last_store;
  float tbval, ang, azang=0.0;
  int count, ktime, iadd, end_flag;
  char *x;
  int irecords;
  int non_size_x, non_size_y, nsx2, nsy2, ix, iy, nsize2;
  float xdeg2, ydeg2, ascale2, bscale2, a02, b02;


  /* SIR file header information */

  float v_min_A, v_max_A, anodata_A, anodata_B, v_min_B, v_max_B, 
    anodata_C, v_min_C, v_max_C, anodata_I, v_min_I, v_max_I, 
    anodata_Ia, v_min_Ia, v_max_Ia;
  int nsx, nsy, ioff_A, iscale_A, iyear, isday, ismin, ieday, iemin;
  int ioff_B, iscale_B, itype_B, ioff_I, iscale_I, itype_I, 
    ioff_Ia, iscale_Ia, itype_Ia, ioff_C, iscale_C, itype_C;
  int ioff_P, iscale_P, itype_P, ioff_V, iscale_V, itype_V, ioff_E, iscale_E, itype_E;
  float anodata_P, v_min_P, v_max_P, anodata_V, v_min_V, v_max_V,
    anodata_E, v_min_E, v_max_E;
  int iregion, itype_A, nhead, ndes, nhtype, idatatype, ldes, nia;
  int ipol, ifreqhm, ispare1;
  char title[101], sensor[41], crproc[101], type_A[139], tag[101], crtime[29];
  char type_B[139], type_I[139], type_Ia[139], type_C[139], type_P[139],
    type_V[139], type_E[139];
  float xdeg, ydeg, ascale, bscale, a0, b0;
  int iopt;
  int ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc;

#define MAXDES 1024
  char descrip[MAXDES+1];
#define MAXI 128
  short iaopt[MAXI];

  int its, irec, ierr, rcode, year, keep, tmax;
  float total;
  char pol;
  float amin, amax, bmin, bmax, weight, temp, old_amin, old_amax,
    old_bmin, old_bmax, denom;

  time_t tod;

  char a_name[100], b_name[100], 
    c_name[100], p_name[100], v_name[100], e_name[100],
    a_name_ave[100], b_name_ave[100], non_aname[100], 
    non_vname[100], grd_aname[100], grd_bname[100], grd_vname[100], 
    grd_pname[100], grd_cname[100], 
    info_name[100], line[100];

  int storage = 0;
  long head_len;
  int errors = 0;
  char polch;

  int ibeam = 0;
 
  int nmax, mdim, mdim2, k, dx, dy, i1, j1;
  int *ix0, *iy0, *ind;
  char **indx;
  float sum, *g, **z, **zc, *u, *v, *u1, *v1, *c, *work, *tb2, *ww, *patarr;
  float p,value1, value2;
  int *fill_array;
  short int *weight_array;

/* begin program */  

  printf("BYU SSM/I meta BG program: C version %f\n",VERSION);

  if (argc < 2) {
    printf("\nusage: %s setup_in outpath gamma delta2 ithres\n\n",argv[0]);
    printf(" input parameters:\n");
    printf("   setup_in = input setup file\n");
    printf("   outpath  = output path\n");
    printf("   gamma    = BGI gamma parameter\n");
    printf("   delta2   = BGI delta2 (noise variance)\n");
    printf("   ithres   = scaled gain threshold (thousandth's in normal space)\n");
    return(0);
  }
  file_in=argv[1];

  imf = fopen(file_in,"r"); 
  if (imf == NULL) {
     eprintfc("ERROR: cannot open input setup file: %s\n",argv[1]); 
     exit(-1);
  }
 
  strncpy(outpath,"./",250); /* default output path */  

  if (argc > 2) sscanf(argv[2],"%s",outpath);
  if (argc > 3) sscanf(argv[2],"%f",&bgi_gamma);
  if (argc > 4) sscanf(argv[3],"%f",&delta2);
  if (argc > 5) sscanf(argv[4],"%f",&ithres);

  printf("BGI options: Nsize=%d omega=%f gamma=%f delta2=%d\n",Nsize, omega, bgi_gamma, delta2);

  /* storage MUST be in ram for BGI processing */
  /* 
  if (argc > 5) sscanf(argv[5],"%d",&storage);
  printf("Storage option %d: ",storage);
  if (storage == 1)
    printf(" File only\n");
  else if (storage == 2)
    printf(" Memory then File\n");
  else
    printf(" Memory only\n");
  */  

  /* get input file size */
  fseek(imf, 0L, REL_EOF);
  nls=ftell(imf);
  rewind(imf);

/* read setup file header info 
   note: setup file is written by a fortran program and so has extra
         record information.  This must be skipped when reading */

/*   read (50) irecords  ! Get number of measurement records in file */

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(0); /* record header */
   if (fread(&irecords,sizeof(int)  , 1, imf) == 0) Ferror(1);
   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(2); /* record trailer */

/*   read (50) nsx,nsy,ascale,bscale,a0,b0,xdeg,ydeg ! Get header info */

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(3); /* record header */
   if (fread(&nsx,   sizeof(int)  , 1, imf) == 0) Ferror(4);
   if (fread(&nsy,   sizeof(int)  , 1, imf) == 0) Ferror(5);
   if (fread(&ascale,sizeof(float), 1, imf) == 0) Ferror(6);
   if (fread(&bscale,sizeof(float), 1, imf) == 0) Ferror(7);
   if (fread(&a0,    sizeof(float), 1, imf) == 0) Ferror(8);
   if (fread(&b0,    sizeof(float), 1, imf) == 0) Ferror(9);
   if (fread(&xdeg,  sizeof(float), 1, imf) == 0) Ferror(10);
   if (fread(&ydeg,  sizeof(float), 1, imf) == 0) Ferror(11);

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(12); /* record trailer */

/*        read (50) dstart,dend,mstart,mend,year,regnum,projt,npol,
     $                  latl,lonl,lath,lonh,regname */

   if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(21);
   if (fread(&isday,  sizeof(int),   1, imf) == 0) Ferror(22);
   if (fread(&ieday,  sizeof(int),   1, imf) == 0) Ferror(23);
   if (fread(&ismin,  sizeof(int),   1, imf) == 0) Ferror(24);
   if (fread(&iemin,  sizeof(int),   1, imf) == 0) Ferror(25);
   if (fread(&iyear,  sizeof(int),   1, imf) == 0) Ferror(26);
   if (fread(&iregion,sizeof(int),   1, imf) == 0) Ferror(27);
   if (fread(&iopt ,  sizeof(int),   1, imf) == 0) Ferror(28);
   if (fread(&ipol,   sizeof(int),   1, imf) == 0) Ferror(29);
   if (fread(&latl,   sizeof(float), 1, imf) == 0) Ferror(30);
   if (fread(&lonl,   sizeof(float), 1, imf) == 0) Ferror(31);
   if (fread(&lath,   sizeof(float), 1, imf) == 0) Ferror(32);
   if (fread(&lonh,   sizeof(float), 1, imf) == 0) Ferror(33);
   if (fread(regname, sizeof(char), 10, imf) == 0) Ferror(34);
   regname[10]='\0';
   if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(35);

/*   read (50) nsx2,nsy2,non_size_x,non_size_y,
     $          ascale2,bscale2,a02,b02,xdeg2,ydeg2 */

   if (fread(&dumb,   sizeof(int)  , 1, imf) == 0) Ferror(43);/* record header */
   if (fread(&nsx2,   sizeof(int)  , 1, imf) == 0) Ferror(44);
   if (fread(&nsy2,   sizeof(int)  , 1, imf) == 0) Ferror(45);
   if (fread(&non_size_x,sizeof(int)  , 1, imf) == 0) Ferror(46);
   if (fread(&non_size_y,sizeof(int)  , 1, imf) == 0) Ferror(47);
   if (fread(&ascale2,sizeof(float), 1, imf) == 0) Ferror(48);
   if (fread(&bscale2,sizeof(float), 1, imf) == 0) Ferror(49);
   if (fread(&a02,    sizeof(float), 1, imf) == 0) Ferror(50);
   if (fread(&b02,    sizeof(float), 1, imf) == 0) Ferror(51);
   if (fread(&xdeg2,  sizeof(float), 1, imf) == 0) Ferror(52);
   if (fread(&ydeg2,  sizeof(float), 1, imf) == 0) Ferror(53);

   if (fread(&dumb,   sizeof(int)  , 1, imf) == 0) Ferror(54);/* record trailer */

   /* file header read completed, summarize */
   printf("\nInput file header info: '%s'\n",file_in);
   printf("  Year, day range: %d %d - %d\n",iyear,isday,ieday);
   printf("  Image size: %d x %d = %d   Projection: %d\n",nsx,nsy,nsx*nsy,iopt);
   printf("  Origin: %f,%f  Span: %f,%f\n",a0,b0,xdeg,ydeg);
   printf("  Scales: %f,%f  Pol: %d  Reg: %d\n",ascale,bscale,ipol,iregion);
   printf("  Region: '%s'   Records: %d\n",regname,irecords);
   printf("  Corners: LL %f,%f UR %f,%f\n",latl,lonl,lath,lonh);
   printf("  Grid size: %d x %d = %d  Scales %d %d\n",nsx2,nsy2,nsx2*nsy2,non_size_x,non_size_y);
   printf("  Grid Origin: %f,%f  Grid Span: %f,%f\n",a02,b02,xdeg2,ydeg2);
   printf("  Grid Scales: %f,%f\n",ascale2,bscale2);
   printf("\n");
   fflush(stdout);

   /* read output file names and misc variables

     In principle, these can be in variable order.  However, if standard
     program is used, order and number is known
   */

   end_flag = 0;
   do {
     
     if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(70);
     if (fread(line,   sizeof(char), 100, imf) == 0) Ferror(71);
     if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(72);
     /* printf("line read '%s'\n",line); */

     if (strstr(line,"A_initialization") != NULL) {
       x = strchr(line,'=');
       a_init=atof(++x);
       //printf("A_initialization of %f\n",a_init);
     }

     if (strstr(line,"Beam_code") != NULL) {
       x = strchr(line,'=');
       ibeam=atoi(++x);
       printf("Beam code %d\n",ibeam);
     }

     /* not needed or used for BGI processing */
     if (strstr(line,"Max_iterations") != NULL) {
       x = strchr(line,'=');
       nits=atoi(++x);
       //printf("Max iterations of %d\n",nits);
     }

     if (strstr(line,"Max_Fill") != NULL) {
       x = strchr(line,'=');
       MAXFILL=atoi(++x);
       //printf("Max fill %d\n",MAXFILL);
     }

     if (strstr(line,"Response_Multiplier") != NULL) {
       x = strchr(line,'=');
       //wscale=1.0/atoi(++x);
       printf("Wscale %d\n",wscale);
     }

     if (strstr(line,"Sensor") != NULL) {
       x = strchr(line,'=');
       strncpy(sensor_in,++x,40);
       no_trailing_blanks(sensor_in);
       printf("Sensor '%s'\n",sensor_in);
     }

     if ((x = strchr(line+4,' ')) != NULL) *x='\0'; /* truncate off any trailing spaces */

     /* not needed or used for BGI processing */
     /*     if (strstr(line,"Median_flag") != NULL) {
       x = strchr(line,'=')+1;
       if (strstr(x,"T") != NULL || strstr(x,"t") != NULL)
	  median_flag=1;
       if (strstr(x,"F") != NULL || strstr(x,"f") != NULL)
	  median_flag=0;
       printf("Median flag: %d\n",median_flag);       
      } */

     if (strstr(line,"Has_Azimuth_Angle") != NULL) {
       x = strchr(line,'=')+1;
       if (strstr(x,"T") != NULL || strstr(x,"t") != NULL) {
	 HASAZANG=1;
	 HS += 4;  /* increase read buffer size */
       }
       if (strstr(x,"F") != NULL || strstr(x,"f") != NULL)
	 HASAZANG=0;
       printf("Has azimuth angle: %d\n",HASAZANG);       
     }

     if (strstr(line,"SIRF_A_file") != NULL) {
       x = strchr(line,'=');
       strncpy(a_name,++x,100);
       no_trailing_blanks(a_name);
     }
     if (strstr(line,"SIRF_C_file") != NULL) {
       x = strchr(line,'=');
       strncpy(c_name,++x,100);
       no_trailing_blanks(c_name);
     }
     /* if (strstr(line,"SIRF_I_file") != NULL) {
       x = strchr(line,'=');
       strncpy(i_name,++x,100);
       no_trailing_blanks(i_name);
     }
     if (strstr(line,"SIRF_J_file") != NULL) {
       x = strchr(line,'=');
       strncpy(j_name,++x,100);
       no_trailing_blanks(j_name);
       }*/
     if (strstr(line,"SIRF_E_file") != NULL) {
       x = strchr(line,'=');
       strncpy(e_name,++x,100);
       no_trailing_blanks(e_name);
     }
     if (strstr(line,"SIRF_V_file") != NULL) {
       x = strchr(line,'=');
       strncpy(v_name,++x,100);
       no_trailing_blanks(v_name);
     }
     if (strstr(line,"SIRF_P_file") != NULL) {
       x = strchr(line,'=');
       strncpy(p_name,++x,100);
       no_trailing_blanks(p_name);
     }
     if (strstr(line,"AVE_A_file") != NULL) {
       x = strchr(line,'=');
       strncpy(a_name_ave,++x,100);
       no_trailing_blanks(a_name_ave);
     }
     if (strstr(line,"NON_A_file") != NULL) {
       x = strchr(line,'=');
       strncpy(non_aname,++x,100);
       no_trailing_blanks(non_aname);
     }
     if (strstr(line,"NON_V_file") != NULL) {
       x = strchr(line,'=');
       strncpy(non_vname,++x,100);
       no_trailing_blanks(non_vname);
     }
     if (strstr(line,"GRD_A_file") != NULL) {
       x = strchr(line,'=');
       strncpy(grd_aname,++x,100);
       no_trailing_blanks(grd_aname);
     }
     if (strstr(line,"GRD_V_file") != NULL) {
       x = strchr(line,'=');
       strncpy(grd_vname,++x,100);
       no_trailing_blanks(grd_vname);
     }
     /*if (strstr(line,"GRD_I_file") != NULL) {
       x = strchr(line,'=');
       strncpy(grd_iname,++x,100);
       no_trailing_blanks(grd_iname);
     }
     if (strstr(line,"GRD_J_file") != NULL) {
       x = strchr(line,'=');
       strncpy(grd_jname,++x,100);
       no_trailing_blanks(grd_jname);
       }*/
     if (strstr(line,"GRD_P_file") != NULL) {
       x = strchr(line,'=');
       strncpy(grd_pname,++x,100);
       no_trailing_blanks(grd_pname);
       }
     if (strstr(line,"GRD_C_file") != NULL) {
       x = strchr(line,'=');
       strncpy(grd_cname,++x,100);
       no_trailing_blanks(grd_cname);
     }
     if (strstr(line,"Info_file") != NULL) {
       x = strchr(line,'=');
       strncpy(info_name,++x,100);
       no_trailing_blanks(info_name);
     }
      
     if (strstr(line,"End_header") != NULL) {
       end_flag = 1;
     }

   } while (end_flag == 0);

   printf("\n");
   printf("A output file: '%s'\n",a_name);
   /* printf("I output file: '%s'\n",i_name);
      printf("J output file: '%s'\n",j_name);*/
   printf("C output file: '%s'\n",c_name);
   printf("P output file: '%s'\n",p_name);
   printf("E output file: '%s'\n",e_name);
   printf("SIR V output file: '%s'\n",v_name);
   printf("AVE A output file: '%s'\n",a_name_ave);
   printf("NON A output file: '%s'\n",non_aname);
   printf("NON V output file: '%s'\n",non_vname);
   printf("GRD A output file: '%s'\n",grd_aname);
   printf("GRD V output file: '%s'\n",grd_vname);
   /* printf("GRD I output file: '%s'\n",grd_iname);
      printf("GRD J output file: '%s'\n",grd_jname);*/
   printf("GRD P output file: '%s'\n",grd_pname);
   printf("GRD C output file: '%s'\n",grd_cname);
   printf("Info file: '%s'\n",info_name);
   printf("\n");

   head_len = ftell(imf);
   printf("Input header file length %ld\n",head_len);
   nls=nls-head_len;

   fflush(stdout);

/* header read completed, now determine how much program memory to allocate */

  if (storage != 1) { /* allocate memory storage space for measurements */
    nspace = nls * file_savings;/* space to allocate for measurement storage */
    printf("  File size: %ld  Space allocated: %ld\n",nls,nspace);
    space = (char *) malloc(sizeof(char)*nspace);
    if (space == NULL) {
      eprintf("*** Inadequate memory for data file storage\n");
      if (storage == 2) {
	eprintf("*** BGI code can not use multiple file option\n\n");
	exit(-1);	
      } else
	exit(-1);
      storage = 1;  /* force use of file */
      eprintf("*** BGI code can not use multiple file option\n\n");
      exit(-1);
    }
  }

/* if program is to be run with file storage (storage=1), allocate working 
   buffer array for file reading */

  if (storage == 1) {
    nspace = 4096;  /* should be adequate for all fill_array sizes */
    space = (char *) malloc(sizeof(int)*nspace/4);
    if (space == NULL) {
      eprintf("*** Inadequate memory for temp storage 1\n");
      exit(-1);
    }
    store2 = (char *) malloc(sizeof(int)*nspace/2);
    if (store2 == NULL) {
      eprintf("*** Inadequate memory for temp storage 2\n");
      exit(-1);
    }
  }
  
/* allocate storage space for image and working array */

  nsize = nsx * nsy;
  
  a_val  = (float *) malloc(sizeof(float)*nsize);
  b_val  = (float *) malloc(sizeof(float)*nsize);
  a_temp = (float *) malloc(sizeof(float)*nsize);
  cnts   = (int *) a_temp;  /* share storage space */
  sxy    = (float *) malloc(sizeof(float)*nsize);
  sx     = (float *) malloc(sizeof(float)*nsize);
  sx2    = (float *) malloc(sizeof(float)*nsize);
  sy     = (float *) malloc(sizeof(float)*nsize);
  tot    = (float *) malloc(sizeof(float)*nsize);

  if (a_val == NULL || b_val == NULL || a_temp == NULL || sxy == NULL
      || sx == NULL ||   sx2 == NULL ||     sy == NULL || tot == NULL) {
     eprintf("*** ERROR: inadequate memory for image working storage\n");
     exit(-1);
  }

   fflush(stdout);  

   /* initialize count array */

   for (i=0; i < nsize; i++)
     cnts[i]=0;
   mdim=0;

  /* with storage allocated, copy file into memory if selected */

  if (storage != 1) {   /* read measurement file into memory, 
			   storing only essential information  */

    nrec = 0;         /* number of meaurements in file */
    ncnt = 0;         /* number of useable measurements */
    nbyte = 0;        /* file size in bytes */
    store=space;      /* storage pointer */
  
    printf("Begin setup file copy into memory\n");
    while (fread(&dumb, sizeof(int), 1, imf) != 0) {

    /*	   read (50,err=500,end=500) tbval,ang,count,ktime,iadd,azi
	   read (50,err=500,end=500) (fill_array(i),i=1,count)
	   read (50,err=500,end=500) (response_array(i),i=1,count)
    */

     /*5 items at 4 bytes each: 20 bytes if no azimuth angle */
     /*6 items at 4 bytes each: 24 bytes if azimuth angle */
     if (nbyte+HS < nspace) {
       	if ((dumb=fread(store, sizeof(char), HS, imf)) != HS) {
          eprintfi(" *** Error reading input file data at 180 %d\n",dumb);
	  exit(-1);
        }
        if (fread(&dumb,sizeof(int), 1, imf) == 0) Ferror(100);

        tbval = *((float *) (store+0));
        ang   = *((float *) (store+4));
        count = *((int *)   (store+8));
        ktime = *((int *)   (store+12));
        iadd  = *((int *)   (store+16));
	if (HASAZANG)
	  azang = *((float *) (store+20));

	if (count > MAXFILL) {
	  printf("*** Count error %d  record %d\n",count,nrec);
	  count=MAXFILL;	  
	}
	/*
	printf("ncnt %d  %f %f  count %d %d %d\n",ncnt,tbval,ang,count,ktime,iadd); 
	if (ncnt > 99) goto label; */

	/* if measurement is "valid" keep it by indexing counters 
           if not, new values will be stored over old values */

	keep=0;
	if (tbval < 340.0 && tbval > 50.0) { 
	  nbyte=nbyte+HS;
	  store=store+HS;
	  ncnt++;
	  keep=1;
	}

	/* read fill_array pixel indices */
	if (nbyte+count*4 < nspace) {
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(110);
	   if (fread(store, sizeof(int), count, imf) != count) {
	      eprintf(" *** Error reading input file data at 111\n");
	      /* exit(-1); */
	      goto label;
	   }

	   if (keep == 1) {
	     last_store=store;
	     nbyte=nbyte+count*4;
	     store=store+count*4;
	   }
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(112);
	} else {
	   eprintfi(" *** out of storage space 1 *** %d\n",ncnt);
	   fprintf(stderr," *** out of storage space 1 *** %d %ld %ld\n",ncnt,nbyte,nspace);
	   exit(-1);
	}

	/* read response_array weights */
	if (nbyte+count*2 < nspace) {
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(1101);
	   if (fread(store, sizeof(short int), count, imf) != count) {
	      eprintf(" *** Error reading input file data at 1111\n");
	      goto label;
	   }
	   if (keep == 1) {
	     count_hits(count, (int *) last_store, (short int *) store, ithres, cnts, &m, nsx);
	     if (m > mdim) mdim = m;
	     if (count % 2 == 1) count=count+1;  /* ensure storage of next record on a 4byte word boundary */
	     nbyte=nbyte+count*2;
	     store=store+count*2;
	   }
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(1121);
	} else {
	   eprintfi(" *** out of storage space 2 *** %d\n",ncnt);
	   fprintf(stderr," *** out of storage space 2 *** %d %ld %ld\n",ncnt,nbyte,nspace);
	   exit(-1);
	}

	nrec++;

     } else {
       eprintfi(" *** out of storage space 3 *** %d\n",ncnt);
       fprintf(stderr," *** out of storage space 3 *** %d %ld\n",ncnt,nspace);
       exit(-1);
     }
    }
  label:
    fclose(imf);


/* print measurement file storage requirements */

    ratio=100.0 * (float) nbyte / (float) nls;
    printf("  Input file read into ram\n");
    printf("  Total storage used: %d %d recs = %ld of %ld (%.1f%% %.1f%%)\n",
	   nrec,ncnt,nbyte,nspace,ratio,100.0*file_savings);
  }
   fflush(stdout);

/* generate output SIR file header info */

  nhtype=31;		/* set header type */
  idatatype=2;		/* output image is in standard i*2 form */
  ipol=ipol+1;
  ifreqhm=1;
  polch='V';
  if (ipol==1) polch='H';
  if (ibeam == 1 || ibeam == 2) {
    ifreqhm=194;
  } else if (ibeam == 3) {
    ifreqhm=222;
  } else if (ibeam == 4 || ibeam == 5) {
    ifreqhm=370;
  } else if (ibeam == 6 || ibeam == 7) {
    ifreqhm=855;
  }

  nia=0;                /* no extra integers */
  ldes=0;               /* no extra text */
  ndes=0;
  ispare1=0;
  strncpy(tag,"(c) 2014 BYU MERS Laboratory",40);
  
  /* expand sensor description */
  sprintf(sensor,"%s %d%c %d",sensor_in,ifreqhm/10,polch,ibeam);  
  regname[9]='\0';

  sprintf(title,"BG image of %s",regname);

  (void) time(&tod);
  (void) strftime(crtime,28,"%X %x",localtime(&tod));
  printf("Current time: '%s'\n",crtime);

  /* set projection scale factors */

  switch (iopt){
  case -1: /* image only */
    ideg_sc=10;
    iscale_sc=1000;
    i0_sc=100;
    ixdeg_off=0;
    iydeg_off=0;
    ia0_off=0;
    ib0_off=0;
    break;
  case 0: /* rectalinear lat/lon */
    ideg_sc=100;
    iscale_sc=1000;
    i0_sc=100;
    ixdeg_off=-100;
    iydeg_off=0;
    ia0_off=0;
    ib0_off=0;
    break;
  case 1: /* lambert */
  case 2:
    ideg_sc=100;
    iscale_sc=1000; /* original = 100 */
    i0_sc=1;
    ixdeg_off=0;
    iydeg_off=0;
    ia0_off=0;
    ib0_off=0;
    break;
  case 5: /* polar stereographic */
    ideg_sc=100;
    iscale_sc=1000;  /* original = 100 */
    i0_sc=1;
    ixdeg_off=-100;
    iydeg_off=0;
    ia0_off=0;
    ib0_off=0;
    break;
  case  8: /* EASE2 grid */
  case  9:
  case 10:
    ideg_sc=10;
    iscale_sc=1000;
    i0_sc=10;
    ixdeg_off=0;
    iydeg_off=0;
    ia0_off=0;
    ib0_off=0;
    break;
  case 11: /* EASE1 grid */
  case 12:
  case 13:
    ideg_sc=10;
    iscale_sc=1000;
    i0_sc=10;
    ixdeg_off=0;
    iydeg_off=0;
    ia0_off=0;
    ib0_off=0;
    break;
  default: /* unknown */
    ideg_sc=100;
    iscale_sc=1000;
    i0_sc=100;
    ixdeg_off=0;
    iydeg_off=0;
    ia0_off=0;
    ib0_off=0;
  }

  /* image specific header info */

  ioff_A=100;
  iscale_A=200;
  itype_A=3;
  anodata_A=100.00;
  v_min_A=180.0;
  v_max_A=295.0;
  sprintf(type_A,"A Tb image  (%s)",a_name);
  
  /*ioff_I=-1;
  iscale_I=100;
  itype_I=7;
  anodata_I=-1.00;
  v_min_I=-1.0;
  v_max_I=1.0;
  sprintf(type_I,"Incidence Angle std  (%s)",a_name);
  
  ioff_Ia=0;
  iscale_Ia=100;
  itype_Ia=9;
  anodata_Ia=0.0;
  v_min_Ia=40.0;
  v_max_Ia=60.0;
  sprintf(type_Ia,"Incidence Angle ave  (%s)",a_name);
  */
  ioff_C=-1;
  iscale_C=9;
  itype_C=8;
  anodata_C=-1.00;
  v_min_C=-1.0;
  v_max_C=500.0;
  sprintf(type_C,"Count image  (%s)",a_name);

  ioff_P=-1;
  iscale_P=1;
  itype_P=11;
  anodata_P=-1.00;
  v_min_P=0.0;
  v_max_P=(ieday-isday)*24*60+iemin-ismin;
  if (v_max_P > 65400.0) v_max_P=65400.0;
  sprintf(type_P,"Pixel Time image  (%s)",a_name);

  ioff_V=-1;
  iscale_V=100;
  itype_V=23;
  anodata_V=-1.00;
  v_min_V=0.0;
  v_max_V=15.0;
  sprintf(type_V,"Tb STD  (%s)",a_name);

  ioff_E=-16;
  iscale_E=100;
  itype_E=21;
  anodata_E=-16.00;
  v_min_E=-15.0;
  v_max_E=15.0;
  sprintf(type_E,"Tb mean error  (%s)",a_name);


  /* determine maximum hits */

  nmax=0;
  for (i=0; i< nsize; i++)
    if (cnts[i] > nmax) nmax=cnts[i];
  printf("\nMaximum hits above threshold: %d  max size: %d\n",nmax,mdim);
  mdim = mdim * 2+1;
 
  /* BG processing */

  /* allocate index array and BGI working arrays*/

  indx = (char **) malloc(sizeof(char *)*nsize*nmax);
  z = matrix(1,nmax,1,nmax);
  zc = matrix(1,nmax,1,nmax);
  u = vector(1,nmax);
  u1 = vector(1,nmax);
  v = vector(1,nmax); 
  v1 = vector(1,nmax); 
  ind = ivector(1,nmax);
  work = vector(1,nmax);
  c = vector(1,nmax);
  tb2 = vector(1,nmax);
  patarr = (float *) malloc(sizeof(float)*mdim*mdim*nmax);
  ix0 = (int *) malloc(sizeof(int)*(nmax+1));
  iy0 = (int *) malloc(sizeof(int)*(nmax+1));
  if (indx == NULL || z == NULL || u == NULL || v == NULL || c == NULL
      || zc == NULL || u1 == NULL || v1 == NULL || ind == NULL
      || work == NULL || tb2 == NULL || patarr == NULL || ix0 == NULL || iy0 == NULL) {
    printf("*** error allocating BGI work arrays \n");
    exit(-1);
  }

  /* create index array */

  for (i=0; i< nsize; i++)
    for (j=0; j< nmax; j++)
      indx[i*nmax+j] = NULL;

  store=space;
  for (irec = 0; irec < ncnt; irec++) {
    last_store=store;
    count = *((int *)   (store+8));
    iadd = *((int *) (store+16));
    store = store+HS;
    store2 = store + 4*count;
  
    make_indx(nmax, count, (int *) store, (short int *) store2, ithres, indx, last_store);
    store = store+4*count;
    store = store+2*count;
    if (count % 2 == 1) store=store+2;  /* ensure word boundary */
}

  printf("Index array created %d %d\n",nsize,ncnt);
  
  
/* Begin BGI processing */

  mdim2=mdim/2+1;

  for (its=0; its < nsize; its++) {   /* for each pixel */
    *(a_val+its) = anodata_A;

    /* print progress */
    if ((its % nsx) == nsx/2  && (its/nsx) % 5 == 0) 
      printf("Processing row %d of %d  %f\n",its/nsx,nsy,amin);
    
    if (cnts[its] > 0) {
      m=0;  /* number of valid measurements */
      for (k=0; k < nmax; k++) {  /* for possible each measurement */
	store = indx[its*nmax + k];
	if (store != NULL) {        /* get measurement info from memory */
	  tbval = *((float *) (store+0));
	  count = *((int *)   (store+8));
	  iadd  = *((int *)  (store+16));
	  iadd = (iadd > 0 ? iadd : -iadd) -1;
	  if (HASAZANG)
	    azang = *((float *) (store+20));	

	  store = store+HS;
	  fill_array = (int *) store;
	  store = store + 4*count;
	  weight_array = (short int *) store;
	  /*
	  printf("at %d %d %d %d\n",its,m,k,count);
	  for (i=0; i < count; i++)
	    printf("  %d %d %d\n",i,fill_array[i],weight_array[i]);
	  */
	  m++;
	  v[m] = 0.0000001;  /* a very small, non-zero value */
	  sum = 0.0;
	  for (i=0; i < count; i++) {
	    if (fill_array[i]-1 == its) 
	      v[m] = weight_array[i]*wscale;
	    sum += weight_array[i]*wscale;
	  }
	  tb2[m] = tbval;
	  v[m]=v[m]/sum;
	  u[m]=1.0;
	
	  ix0[m] = iadd % nsx;
	  iy0[m] = iadd / nsx;

	  for (i=0; i< mdim*mdim; i++)
	    patarr[i*nmax+m-1]=0.0;
	
	  for (i=0; i < count; i++) {
	    ix = (fill_array[i]-1) % nsx - ix0[m] + mdim2;
	    iy = (fill_array[i]-1) / nsx - iy0[m] + mdim2;
	    if (ix >= 0 && iy >= 0 && ix < mdim && iy < mdim)
	      patarr[(iy*mdim+ix)*nmax+m-1]=weight_array[i]*wscale;
	    else
	      printf("*** patarr error %d %d %d  %d\n",i,ix,iy,its);
	  }
	}
      }

      if (m > 0) {

	/* compute z matrix */
	for (i=1; i <= m; i++)
	  for (j=1; j <= m; j++) {
	    dx = ix0[i] - ix0[j];
	    dy = iy0[i] - iy0[j];
	    z[i][j] = 0.0;
	    sum=0.0;
	    for (i1=1; i1 <= mdim; i1++)
	      for (j1=1; j1 <= mdim; j1++) {
		ix=i1-dx;
		iy=j1-dy;
		if (ix > 0 && iy > 0 && ix <= mdim && iy <= mdim)
		  sum = sum + patarr[((j1-1)*mdim+i1-1)*nmax+i-1]*patarr[((iy-1)*mdim+ix-1)*nmax+j-1];
	      } 
	    z[i][j] = sum * cos(bgi_gamma);

	    if (i == j) z[i][j] =  z[i][j] + omega * sin(bgi_gamma) * delta2;
	    z[j][i] = z[i][j];
	    /*	    printf("in z %d %d %d %d %f %f\n",i,j,dx,dy,sum*cos(bgi_gamma),z[dx,dy]); */
	  }
	/*
	printf("z is: %d %d %f\n",m,m,omega * sin(bgi_gamma) * delta2);
	for (i=1;i<=m;i++) {
	  for (j=1;j<=m;j++)
	    printf("%f ",z[i][j]);
	  printf("\n");
	}
	*/

	/* Do LU decomposition */
	ludcmp(z,m,ind,&p);

	for (i=1;i<=m;i++) {
	  u1[i]=u[i];
	  v1[i]=v[i];
	  for (j=1;j<=m;j++)
	    zc[i][j] = z[i][j];
	}
      
      /* solve linear system z x = u [compute z^-1 u]  (u and z destroyed in process) */
	lubksb(z,m,ind,u1);

      /* comute u^t z^-1 u */
	value2 = 0.0;
	for (i=1; i <= m; i++)
	  value2 = value2 + u[i] * u1[i];

	for (i=1;i<=m;i++)
	  for (j=1;j<=m;j++)
	    z[i][j] = zc[i][j];

      /* solve linear system z x = v [compute z^-1 v]  (v and z destroyed in process) */
	lubksb(z,m,ind,v1);

      /* comute u^t z^-1 v */
	value1 = 0.0;
	for (i=1; i <= m; i++)
	  value1 = value1 + u[i] * v1[i];

      /* compute work vector */
	for (i=1; i <= m; i++)
	  work[i] = cos(bgi_gamma)*v[i] + u[i] * (1.0 - cos(bgi_gamma) * value1)/value2;
      
      /* solve linear system z c = work [compute z^-1 work]  (destroyed in process) */
	lubksb(zc,m,ind,work);
      
      /* compute BG pixel estimate value */
	sum = 0.0;
	for (i=1; i <= m; i++)
	  sum = sum + work[i] * tb2[i];
	a_val[its] = sum;
	/*
	printf("one %d %d  %f %f %f\n",its,m,sum,value1,value2);
	for (i=1; i <= m; i++)
	  printf("%d %f %f %f %f %f %f\n",i,u[i],v[i],u1[i],v1[i],work[i],tb2[i]);
	*/
	amin=a_val[its];
	
      } else /* pixel not hit, set its value to the default nodata value */
	a_val[its] = anodata_A;
    } 
  }

 /* output image file */
 sprintf(crproc,"BYU MERS:meas_meta_bgi v1.0 g=%f d2=%f thres=%f",bgi_gamma,delta2,ithres*wscale);

 /* generate BG output name */
 s=strncpy(line,a_name,100);
 s=strchr(line,'.');
 if (s != NULL) *s ='\0';
 sprintf(a_name,"%s.bgi",line);

 printf("\n"); 
 printf("Writing A output BGI file '%s'\n", addpath(outpath,a_name,tstr));
 ierr = write_sir3(addpath(outpath,a_name,tstr), a_val, &nhead, nhtype, 
		   idatatype, nsx, nsy, xdeg, ydeg, ascale, bscale, a0, b0, 
		   ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		   ioff_A, iscale_A, iyear, isday, ismin, ieday, iemin, 
		   iregion, itype_A, iopt, ipol, ifreqhm, ispare1,
		   anodata_A, v_min_A, v_max_A, sensor, title, type_A, tag,
		   crproc, crtime, descrip, ldes, iaopt, nia);
 if (ierr < 0) {
   eprintf("*** ERROR writing A output file ***\n");
   errors++;
 } else
   printf("Successfully wrote product file\n");

 if (1) /* skip production of other files */
   goto label_end; 

/* create STD and Err images */

  printf("\nBegin creation of STD images\n");  
  fflush(stdout);

  /* initialize arrays */

  for (i=0; i < nsize; i++) {
    *(a_temp+i) = 0.0;
    *(sx+i)  = 0.0;
    *(sy+i)  = 0.0;
    *(sxy+i) = 0.0;
    *(sx2+i) = 0.0;
    *(tot+i) = 0.0;
  }

  if (storage == 1) {  /* file storage: rewind file and skip head */
    fseek(imf, head_len, REL_BEGIN);
  }

  store=space;
  for (irec = 0; irec < ncnt; irec++) {

    if (storage == 1) { /* get measurement info from file */

      store=space;
      if (get_measurements(store, store2, &tbval, &ang, &count,
			   &ktime, &iadd, &nrec)) goto done1;
      
    } else {  /* get measurement info from memory */

      tbval = *((float *) (store+0));
      ang   = *((float *) (store+4));
      count = *((int *)   (store+8));
      if (HASAZANG)
	azang = *((float *) (store+20));
      
      store = store+HS;
      store2 = store+4*count;
    }

    stat_updates(tbval, ang, count, (int *) store, (short int *) store2);
    store = store+4*count;
    store = store+2*count;
    if (count % 2 == 1) store=store+2;  /* ensure word boundary */
  }
done1:

  amin =  32000.0;            /* for user stats */
  amax = -32000.0;
  bmin =  300.0;
  bmax = -300.0;
  total = 0.0;
    
  for (i=0; i<nsize; i++){
    if (*(tot+i) > 0) {    /* update only hit pixels */
      total = total + *(tot+i);
      *(sx+i) = *(sx+i) / *(tot+i); /* first moment (mean) */
      *(sy+i) = *(sy+i) / *(tot+i); /* second moment */
      
      if (*(sy+i) > 0.0) {
	*(sxy+i) = *(sy+i) - *(sx+i) * *(sx+i);
	if (*(sxy+i) > 0.0) 
	  *(sxy+i) = sqrt( (double) *(sxy+i));
	else
	  *(sxy+i) = 0.0;
      } else
	  *(sxy+i) =0.0;
		
      amin = min(amin, *(sxy+i));
      amax = max(amax, *(sxy+i));
      bmin = min(bmin, *(sx+i));
      bmax = max(bmax, *(sx+i));
	
      } else {
	*(sxy+i) = anodata_V;
	*(sx+i) = anodata_E;
      }
  }
    
  printf(" Tb STD min   max --> %f %f\n",amin,amax);
  printf(" Tb ERR min   max --> %f %f\n",bmin,bmax);

  sprintf(title,"Tb STD image of %s",regname);
  printf("Writing Tb STD (V) output SIR file '%s'\n", v_name);
  ierr = write_sir3(addpath(outpath,v_name,tstr), sxy, &nhead, nhtype, 
		    idatatype, nsx, nsy, xdeg, ydeg, ascale, bscale, a0, b0, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_V, iscale_V, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_V, iopt, ipol, ifreqhm, ispare1,
		    anodata_V, v_min_V, v_max_V, sensor, title, type_V, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing Tb STD (V) output file ***\n");
    errors++;
  }

  sprintf(title,"Tb err image of %s",regname);
  printf("Writing Tb err (E) output SIR file '%s' \n", e_name);
  ierr = write_sir3(addpath(outpath,e_name,tstr), sx, &nhead, nhtype, 
		    idatatype, nsx, nsy, xdeg, ydeg, ascale, bscale, a0, b0, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_E, iscale_E, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_E, iopt, ipol, ifreqhm, ispare1,
		    anodata_E, v_min_E, v_max_E, sensor, title, type_E, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    printf("*** ERROR writing Tb err (E) output file ***\n");
    errors++;
  }



/* create time image */

  printf("\nBegin creation of time image\n");  
   fflush(stdout);

  /* initialize arrays */

  for (i=0; i < nsize; i++) {
    *(a_temp+i) = 0.0;
    *(sx+i)  = 0.0;
    *(sy+i)  = 0.0;
    *(sxy+i) = 0.0;
    *(tot+i) = 0.0;
  }

  if (storage == 1) {  /* file storage: rewind file and skip head */
    fseek(imf, head_len, REL_BEGIN);
  }

  store=space;
  for (irec = 0; irec < ncnt; irec++) {


    if (storage == 1) { /* get measurement info from file */

      store=space;
      if (get_measurements(store, store2, &tbval, &ang, &count,
			   &ktime, &iadd, &nrec)) goto done2;
      
    } else {  /* get measurement info from memory */

      tbval = *((float *) (store+0));
      ang   = *((float *) (store+4));
      count = *((int *)   (store+8));
      ktime = *((int *)   (store+12));
      if (ktime < 0) ktime = -ktime;
      if (HASAZANG)
	azang = *((float *) (store+20));	

      store = store+HS;
      store2 = store+4*count;     
    }

    time_updates(tbval, (float) ktime, ang, count, (int *) store, (short int *) store2);
    store = store+4*count;
    store = store+2*count;
    if (count % 2 == 1) store=store+2;  /* ensure word boundary */
  }
done2:

  amin =  32000.0;            /* for user stats */
  amax = -32000.0;
  total = 0.0;
    
  for (i=0; i<nsize; i++){
    if (*(tot+i) > 0) {    /* update only hit pixels */
      total = total + *(tot+i);

      if (*(tot+i) > 1) 
	if (*(sy+i) != 0.0) 
	  *(sxy+i) = *(sx+i) / *(sy+i);
	else
	  *(sxy+i) =0.0;
      else
	*(sxy+i) = anodata_P;
		
      amin = min(amin, *(sxy+i));
      amax = max(amax, *(sxy+i));
	
    } else
      *(sxy+i) = anodata_P;
  }

  printf(" Time (prefilter)  min   max --> %f %f\n",amin,amax);

  /* median filter time image */

  filter(sxy, 3, 0, nsx, nsy, a_temp, anodata_P);

  amin =  32000.0;            /* for user stats */
  amax = -32000.0;

  for (i=0; i<nsize; i++){
    if (*(tot+i) > 0) {
      amin = min(amin, *(sxy+i));
      amax = max(amax, *(sxy+i));
    };
  }

  printf(" Time (postfilter) min   max --> %f %f\n",amin,amax);
  fflush(stdout);

  sprintf(title,"Pixel Time image of %s",regname);
  printf("Writing time output (P) SIR file '%s'\n", p_name);
  ierr = write_sir3(addpath(outpath,p_name,tstr), sxy, &nhead, nhtype, 
		    idatatype, nsx, nsy, xdeg, ydeg, ascale, bscale, a0, b0, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_P, iscale_P, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_P, iopt, ipol, ifreqhm, ispare1,
		    anodata_P, v_min_P, v_max_P, sensor, title, type_P, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing time output (P) file ***\n");
    errors++;
  }


/* create non-enhanced images */

  printf("\nBegin creation of non-enhanced image\n");
  fflush(stdout);

  /* note that this should be the case: 
     nsx2 = nsx/non_size_x;
     nsy2 = nsy/non_size_y; */

  nsize2=nsx2*nsy2;

  /* initialize arrays */

  for (i=0; i < nsize2; i++) {
    *(a_val+i) = 0.0;
    *(a_temp+i) = 0.0;
    *(tot+i) = 0;
    *(sx+i)  = 0.0;
    *(sy+i)  = 0.0;
    *(sxy+i) = 0.0;
    *(sx2+i) = 0.0;
 }

  if (storage == 1) {  /* file storage: rewind file and skip head */
    fseek(imf, head_len, REL_BEGIN);
  }

  store=space;
  for (irec = 0; irec < ncnt; irec++) {

    if (storage == 1) { /* get measurement info from file */
      store=space;
      if (get_measurements(store, store2, &tbval, &ang, &count,
			   &ktime, &iadd, &nrec)) goto done3;
      
    } else {  /* get measurement info from memory */
      tbval = *((float *) (store+0));
      ang   = *((float *) (store+4));
      count = *((int *)   (store+8));
      iadd  = *((int *)   (store+16));
      if (HASAZANG)
	azang = *((float *) (store+20));
      store = store+HS;
    }
    store = store+4*count;
    store = store+2*count;
    if (count % 2 == 1) store=store+2;  /* ensure word boundary */

    /* compute address in shrunk workspace */

    if (iadd < 0) iadd=-iadd;  /* remove asc/des flag */
    if (iadd > 0) {            /* skip out-of-area measurements */

      /* compute location of measurement within lo-res grid */

      ix = (iadd - 1) % nsx;
      iy = (iadd - 1) / nsx;
      ix = ix / non_size_x;
      iy = iy / non_size_y;
      iadd = nsx2*iy+ix; 

    /* compute average and variance */

      if (iadd >= nsx2*nsy2 || iadd < 0) {  /* keep only in-image
					      measurements */
	printf("*** Non-enhanced address error: %d %d %d %d %d\n",
	       iadd,ix,iy,non_size_x,non_size_y);
      } else {
	n = *(tot + iadd);
	*(tot +  iadd) = *(tot +   iadd) + 1;
	/*	*(sx +   iadd) = (*(sx +   iadd) * n + ang)/(n+1);
	 *(sx2 +  iadd) = (*(sx2 +  iadd) * n + ang*ang)/(n+1); */
	*(sy +   iadd) = (*(sy +   iadd) * n + tbval)/(n+1);	
	*(sxy +  iadd) = (*(sxy +  iadd) * n + tbval*ang)/(n+1);	
	*(a_val+ iadd) = (*(a_val+ iadd) * n + tbval*tbval)/(n+1);	
	*(a_temp+iadd) = (*(a_temp+iadd) * n + ktime)/(n+1);
      }
    }
  }
done3:

  amin =  32000.0;            /* for user stats */
  amax = -32000.0;
  bmin =  32000.0;
  bmax = -32000.0;
  old_bmax = -3200.0;
  old_bmin =  3200.0;
  tmax = -1;
  total = 0.0;
    
  for (i=0; i<nsize2; i++){
    if (*(tot+i) > 0) {    /* update only hit pixels */
      total = total + *(tot+i);

      temp =  *(a_val + i) - *(sy + i) * *(sy + i);
      if (temp > 0.0) {
	temp = sqrt((double) temp);
	old_bmin = min(old_bmin, temp);
	old_bmax = max(old_bmax, temp);
      } else
	temp = anodata_V;

      *(a_val+i) = *(sy+i);
      /*      if (*(tot+i) > 1) {
	denom = *(sx2+i) - (*(sx+i) * *(sx+i));
	if (denom > 0.0) {
	  *(sx2+i) = sqrt(denom);
	  }
      } else {
	  *(sx2+i) = anodata_I;
      }*/
      /*
      if (*(a_val+i) >  32.0) *(a_val+i) =  32.0;
      if (*(a_val+i) < -50.0) *(a_val+i) = -50.0;
      */
      amin = min(amin, *(a_val+i));
      amax = max(amax, *(a_val+i));

      *(sxy+i) = temp;
      tmax = max(tmax, *(tot+i));
      *(sy+i) = *(tot+i);
	
    } else {
      *(a_val+i) = anodata_A;
      *(a_temp+i) = anodata_P;
      *(sxy+i) = anodata_V;
      /* *(sx+i) = anodata_Ia;
       *(sx2+i) = anodata_I;*/
      *(sy+i) = anodata_C;
    }
  }

  printf(" Non-enhanced/Grid A  min   max --> %f %f\n",amin,amax);
  printf(" Non-enhanced/Grid V  min   max --> %f %f\n",old_bmin,old_bmax);
  fflush(stdout);

  if (old_bmax < 1.0)
    v_max_V = 1;

  sprintf(title,"Grid image of %s",regname);
  printf("Writing Grid A output SIR file '%s'\n", grd_aname);
  ierr = write_sir3(addpath(outpath,grd_aname,tstr), a_val, &nhead, nhtype, 
		    idatatype, nsx2, nsy2, xdeg2, ydeg2, 
		    ascale2, bscale2, a02, b02, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_A, iscale_A, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_A, iopt, ipol, ifreqhm, ispare1,
		    anodata_A, v_min_A, v_max_A, sensor, title, type_A, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing grid output A file ***\n");
    errors++;
  }

  sprintf(title,"Grid Tb STD image of %s",regname);
  printf("Writing Grid Tb STD (V) output SIR file '%s'\n", grd_vname);
  ierr = write_sir3(addpath(outpath,grd_vname,tstr), sxy, &nhead, nhtype, 
		    idatatype, nsx2, nsy2, xdeg2, ydeg2, 
		    ascale2, bscale2, a02, b02, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_V, iscale_V, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_V, iopt, ipol, ifreqhm, ispare1,
		    anodata_V, v_min_V, v_max_V, sensor, title, type_V, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing Grid Tb (V) STD output file ***\n");
    errors++;
  }

  /*printf("Writing Grid Istd (I) output file '%s'\n", grd_iname);
  ierr = write_sir3(addpath(outpath,grd_iname,tstr), sx2, &nhead, nhtype, 
                    idatatype, nsx2, nsy2, xdeg2, ydeg2,
		    ascale2, bscale2, a02, b02, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_I, iscale_I, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_I, iopt, ipol, ifreqhm, ispare1,
		    anodata_I, v_min_I, v_max_I, sensor, title, type_I, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing Istd output file ***\n");
    errors++;
  }

  printf("Writing Grid Iave (J) output file '%s'\n", grd_jname);
  ierr = write_sir3(addpath(outpath,grd_jname,tstr), sx, &nhead, nhtype, 
                    idatatype, nsx2, nsy2, xdeg2, ydeg2,
		    ascale2, bscale2, a02, b02, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_Ia, iscale_Ia, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_Ia, iopt, ipol, ifreqhm, ispare1,
		    anodata_Ia, v_min_Ia, v_max_Ia, sensor, title, type_Ia, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing Istd output file ***\n");
    errors++;
  }
  */

  printf("Writing Grid Cnt (C) output file '%s' %d\n", grd_cname, tmax);
  v_max_C = (float) (10 * (tmax/10+1));
  ierr = write_sir3(addpath(outpath,grd_cname,tstr), sy, &nhead, nhtype, 
		    idatatype, nsx2, nsy2, xdeg2, ydeg2,
		    ascale2, bscale2, a02, b02, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_C, iscale_C, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_C, iopt, ipol, ifreqhm, ispare1,
		    anodata_C, v_min_C, v_max_C, sensor, title, type_C, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing Istd output file ***\n");
    errors++;
  }

  sprintf(title,"Grid Pixel Time image of %s",regname);
  printf("Writing Grid time (P) file '%s'\n", grd_pname);
  ierr = write_sir3(addpath(outpath,grd_pname,tstr), a_temp, &nhead, nhtype, 
		    idatatype, nsx2, nsy2, xdeg2, ydeg2,
		    ascale2, bscale2, a02, b02, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_P, iscale_P, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_P, iopt, ipol, ifreqhm, ispare1,
		    anodata_P, v_min_P, v_max_P, sensor, title, type_P, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing Grid time output (P) file ***\n");
    errors++;
  }
  fflush(stdout);

  /* create images with same pixel sizes as enhanced resolution images
     using grid image data */

  for (i=0; i < nsize; i++) {
    *(sx + i) = anodata_A;
    *(sy + i) = anodata_V;
  }
  
  for (i=0; i < nsize2; i++) {
    ix = (i % nsx2) * non_size_x;
    iy = (i / nsx2) * non_size_y;

    for (ii=0; ii < non_size_y; ii++)
      for (iii=0; iii < non_size_x; iii++) {
	iadd = nsx*(iy+ii)+ix+iii;
	*(sx + iadd) = *(a_val + i);
	*(sy + iadd) = *(sxy + i);
      }
  }
  
/* write sir format output files */

  sprintf(title,"Non-enhanced image of %s",regname);
  printf("Writing Non-enhanced A output SIR file '%s'\n", non_aname);
  ierr = write_sir3(addpath(outpath,non_aname,tstr), sx, &nhead, nhtype, 
		    idatatype, nsx, nsy, xdeg, ydeg, 
		    ascale, bscale, a0, b0, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_A, iscale_A, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_A, iopt, ipol, ifreqhm, ispare1,
		    anodata_A, v_min_A, v_max_A, sensor, title, type_A, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing nonenhanced output A file ***\n");
    errors++;
  }

  sprintf(title,"Non-enhanced Tb STD image of %s",regname);
  printf("Writing Non-enhanced Tb STD (V) output SIR file '%s'\n", non_vname);
  ierr = write_sir3(addpath(outpath,non_vname,tstr), sy, &nhead, nhtype, 
		    idatatype, nsx, nsy, xdeg, ydeg, 
		    ascale, bscale, a0, b0, 
		    ixdeg_off, iydeg_off, ideg_sc, iscale_sc, ia0_off, ib0_off, i0_sc,
		    ioff_V, iscale_V, iyear, isday, ismin, ieday, iemin, 
		    iregion, itype_V, iopt, ipol, ifreqhm, ispare1,
		    anodata_V, v_min_V, v_max_V, sensor, title, type_V, tag,
		    crproc, crtime, descrip, ldes, iaopt, nia);
  if (ierr < 0) {
    eprintf("*** ERROR writing Non-enhanced Tb (V) STD output file ***\n");
    errors++;
  }
  fflush(stdout);

  /* write out info file if processing successful */
 label_end:;

  if (errors == 0) {
    omf = fopen(info_name,"a"); 
    if (omf == NULL) {
      eprintfc("ERROR: cannot open info file: '%s'\n",info_name); 
    } else {
      fprintf(omf,"BG Processing of '%s' successfully completed\n",file_in);
      fprintf(omf,"A output file: '%s'\n",a_name);
      /*  fprintf(omf,"I output file: '%s'\n",i_name);
	  fprintf(omf,"J output file: '%s'\n",j_name);*/
   /* fprintf(omf,"C output file: '%s'\n",c_name); */
      fprintf(omf,"P output file: '%s'\n",p_name);
      fprintf(omf,"V output file: '%s'\n",v_name);
      fprintf(omf,"E output file: '%s'\n",e_name);
      fprintf(omf,"NON A output file: '%s'\n",non_aname);
      fprintf(omf,"NON V output file: '%s'\n",non_vname);
      fprintf(omf,"GRD A output file: '%s'\n",grd_aname);
      fprintf(omf,"GRD V output file: '%s'\n",grd_vname);
      /*   fprintf(omf,"GRD I output file: '%s'\n",grd_iname);
	   fprintf(omf,"GRD J output file: '%s'\n",grd_jname);*/
      fprintf(omf,"GRD P output file: '%s'\n",grd_pname);
      fprintf(omf,"GRD C output file: '%s'\n",grd_cname);
      fclose(omf);
    }
  }
  
/* end of program */

  /* free malloc'ed memory (not strictly necessary, but good to be explicit) */
  free(space);
  free(a_val);
  free(b_val);
  free(a_temp);
  free(sxy);
  free(sx);
  free(sx2);
  free(sy);
  free(tot);

  return(errors);
}


/* ***************** support routines **************** */

void count_hits(int count, int fill_array[], short int response_array[], short int ithres, int cnt[], int *mdim,int nsx)
{
  static int i,n,m,x,y,xx,yx,xn,yn;

  yx=xx=0;
  yn=xn=99999999;
  for (i=0; i < count; i++) {
    n=fill_array[i]-1;
    m=response_array[i];
    if (m > ithres) {
      (cnt[n])++;
      x = n % nsx;
      y = n / nsx;
      xx = max(x,xx);
      yx = max(y,yx);
      xn = min(x,xn);
      yn = min(y,yn);
    }
  }
  x=xx-xn+1;
  y=yx-yn+1;
  *mdim=max(x,y);
}

void make_indx(int nmax, int count, int fill_array[], short int response_array[], short int ithres, char **indx, char *pointer)
{
  static int i,j,m,n;
  
  for (i=0; i < count; i++) {
    n=fill_array[i]-1;
    m=response_array[i];
    if (m > ithres) {
      j = 0;
      while (j < nmax && indx[n*nmax+j] != NULL) j++;
      if (j < nmax) indx[n*nmax+j]=pointer;
    }
  }  
}



/* routine to compute variance and error from measurements */

void stat_updates(float tbval, float ang, int count, int fill_array[],
		  short int response_array[])
{
  float ave, sigv;
  float total=0.0, num=0.0;
  int i, n, m;

  /* compute forward projection of measurement */
  
  for (i=0; i < count; i++) {
    n=fill_array[i];
    m=response_array[i];
    sigv = *(a_val+n-1);
    total = total + m * sigv;
    num = num + m;
  }
  if (num == 0) return;

  /*  ave = 10.0 * log10( (double) (total/num)); */
  ave =(double) (total/num);
  

  for (i=0; i < count; i++) {
    n=fill_array[i];
    m=response_array[i];
    *(tot+n-1) = *(tot+n-1) + m;
    sigv = (tbval - ave);      /* difference */
    *(sx+n-1) = *(sx+n-1) + m * sigv;
    *(sy+n-1) = *(sy+n-1) + m * sigv * sigv;
  }

  return;
}


/* modified median or smoothing filter routine */

float median(float *array, int count);

void filter(float *val, int size, int mode, int nsx, int nsy, 
	    float *temp, float thres)
{
  float array[100], total;
  int i,j,x,y,size2,count,x1,x2,y1,y2;
  
  if ((size % 2) == 0) size=size+1;   /* force window size odd */
  size2 = (size-1)/2;                 /* window center */

  for (x=1; x<= nsx; x++)
    for (y=1; y<= nsy; y++) {
      count=0;
      y1=max(y-size2,1);
      y2=min(y+size2,nsy);
      x1=max(x-size2,1);
      x2=min(x+size2,nsx);
      for (i=x1; i <= x2; i++)
	for (j=y1; j <= y2; j++)
	  if (*(val+i+(j-1)*nsx-1) > thres) {
	    array[count]=*(val+i+(j-1)*nsx-1);
	    count++;
	  };
      
      if (count > 0 && *(val+x+(y-1)*nsx-1) > thres) {
	if (mode == 0)  /* Mode 0 = median */
	  *(temp+(y-1)*nsx+x-1) = median(array,count);
	else {		/* Mode 1 = average */
	  total=0.0;
	  for (i=0; i<count; i++)
	    total=total+array[i];
	  *(temp+(y-1)*nsx+x-1) = total/count;
	}
      } else
	*(temp+(y-1)*nsx+x-1) = thres;
    };
  
  for (i=0; i < nsx*nsy; i++) {
    *(val+i) = *(temp+i);
    *(temp+i)=0.0;
  }
  return;
}

/* compute modified median of an array of values */

float median(float array[], int count)
{
  int i,j;
  float temp;

  for (i=count; i >= 2; i--)
    for (j=1; j <= i-1; j++)
      if (array[i-1] < array[i-j-1]) {
	temp=array[i-1];
	array[i-1]=array[i-j-1];
	array[i-j-1]=temp;
      };
  
  temp=array[count/2];

  if (array[count-2]-array[1] < 0.25 && count > 5) {
    temp=0.0;
    for (i=count/2-1; i <= count/2+3; i++)
      temp=temp+array[i-1];
    temp=temp/5.0;
  }
  return(temp);
}


/* routine to compute weighted time estimates from measurements */

void time_updates(float tbval, float ktime, float ang, int count,
		  int fill_array[], short int response_array[])
{
  float ave;
  int i, n;
  
  for (i=0; i < count; i++) {
    n=fill_array[i];
    *(tot+n-1) = *(tot+n-1) + 1;
    ave = tbval;
    *(sx+n-1) = *(sx+n-1) + ktime / ave;
    *(sy+n-1) = *(sy+n-1) + 1.0 / ave;
  }
  return;
}


void Ferror(int i)
{
  fprintf(stdout,"*** Error reading input file at %d ***\n",i);
  fprintf(stderr,"*** Error reading input file at %d ***\n",i);
  fflush(stdout);
  fflush(stderr);
  return;
  /* exit(-1); */
}


int get_measurements(char *store, char *store2, float *tbval, float *ang, int *count,
		     int *ktime, int *iadd, int *nrec)
{  /* returns the next set of measurement from the file */
  int dumb, flag=1;
  
  while (flag == 1) {
    if (fread(&dumb, sizeof(int), 1, imf) != 0) {  /* fortran record header */
      /*	   read	 (50,err=500,end=500) tbval,ang,count,ktime,iadd
		   read (50,err=500,end=500) (fill_array(i),i=1,count)   */
      if (fread(store, sizeof(char), HS, imf) != HS) Ferror(200);
      if (fread(&dumb,sizeof(int), 1, imf) == 0) Ferror(201); /* fortran 
								record trailer */
      *tbval   = *((float *) (store+0));
      *ang   = *((float *) (store+4));
      *count = *((int *)   (store+8));
      *ktime = *((int *)   (store+12));
      *iadd  = *((int *)   (store+16));
      /* if (HASAZANG)
       *azang = *((float *) (store+20)); */

      /*
      printf("record %d %f %f %d %d %d\n",*nrec,*tbval,*ang,*count,*ktime,*iadd);
      */

      /* read fill_array pixel indices */
      if (*count * 4 < nspace) {
	if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(210); 
	if (fread(store, sizeof(int), *count, imf) != *count) Ferror(211);
	if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(212);
      } else {
	fprintf(stdout," *** fill_array storage error 3 *** %d %ld\n",*nrec,nspace);
	fprintf(stderr," *** fill_array storage error 3 *** %d %ld\n",*nrec,nspace);
	exit(-1);
      }

      /* read response_array values */
      if (*count * 2 < nspace) {
	if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(2101); 
	if (fread(store2, sizeof(short int), *count, imf) != *count) Ferror(2111);
	if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(2121);
      } else {
	fprintf(stdout," *** fill_array storage error 4 *** %d %ld\n",*nrec,nspace);
	fprintf(stderr," *** fill_array storage error 4 *** %d %ld\n",*nrec,nspace);
	exit(-1);
      }
      (*nrec)++;
	
      if (*tbval < 340.0 && *tbval > 50.0) return(0);
    } else      /* end of file (or file err) encountered */
      return(1);
  }
  return(0);
}


void no_trailing_blanks(char *s)
{  /* remove trailing blanks (spaces) from string */
  int n=strlen(s);
  
  while (n > 0) {
    if (s[n] != ' ' && s[n] != '\0') return;
    if (s[n] == ' ') s[n] = '\0';
    n--;
  }
  return;
}

char *addpath(char *outpath, char *name, char *temp)
{ /* append path to name, return pointer to temp */
  sprintf(temp,"%s/%s",outpath,name);
  return(temp);  
}

/****************************************************************************/

/* Numerical Recipes routines */

void lubksb(float **a, int n, int *indx, float b[])
{
	int i,ii=0,ip,j;
	float sum;

	for (i=1;i<=n;i++) {
		ip=indx[i];
		sum=b[ip];
		b[ip]=b[i];
		if (ii)
			for (j=ii;j<=i-1;j++) sum -= a[i][j]*b[j];
		else if (sum) ii=i;
		b[i]=sum;
	}
	for (i=n;i>=1;i--) {
		sum=b[i];
		for (j=i+1;j<=n;j++) sum -= a[i][j]*b[j];
		b[i]=sum/a[i][i];
	}
}

#define TINY 1.0e-20;

void ludcmp(float **a, int n, int *indx, float *d)
{
	int i,imax,j,k;
	float big,dum,sum,temp;
	float *vv;

	vv=vector(1,n);
	*d=1.0;
	for (i=1;i<=n;i++) {
		big=0.0;
		for (j=1;j<=n;j++)
			if ((temp=fabs(a[i][j])) > big) big=temp;
		if (big == 0.0) nrerror("Singular matrix in routine ludcmp");
		vv[i]=1.0/big;
	}
	for (j=1;j<=n;j++) {
		for (i=1;i<j;i++) {
			sum=a[i][j];
			for (k=1;k<i;k++) sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
		}
		big=0.0;
		for (i=j;i<=n;i++) {
			sum=a[i][j];
			for (k=1;k<j;k++)
				sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
			if ( (dum=vv[i]*fabs(sum)) >= big) {
				big=dum;
				imax=i;
			}
		}
		if (j != imax) {
			for (k=1;k<=n;k++) {
				dum=a[imax][k];
				a[imax][k]=a[j][k];
				a[j][k]=dum;
			}
			*d = -(*d);
			vv[imax]=vv[j];
		}
		indx[j]=imax;
		if (a[j][j] == 0.0) a[j][j]=TINY;
		if (j != n) {
			dum=1.0/(a[j][j]);
			for (i=j+1;i<=n;i++) a[i][j] *= dum;
		}
	}
	free_vector(vv,1,n);
}
#undef TINY

/* CAUTION: This is the ANSI C (only) version of the Numerical Recipes
   utility file nrutil.c.  Do not confuse this file with the same-named
   file nrutil.c that is supplied in the 'misc' subdirectory.
   *That* file is the one from the book, and contains both ANSI and
   traditional K&R versions, along with #ifdef macros to select the
   correct version.  *This* file contains only ANSI C.               */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#define NR_END 1
#define FREE_ARG char*

void nrerror(char error_text[])
/* Numerical Recipes standard error handler */
{
	fprintf(stderr,"Numerical Recipes run-time error...\n");
	fprintf(stderr,"%s\n",error_text);
	fprintf(stderr,"...now exiting to system...\n");
	exit(1);
}

float *vector(long nl, long nh)
/* allocate a float vector with subscript range v[nl..nh] */
{
	float *v;

	v=(float *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(float)));
	if (!v) nrerror("allocation failure in vector()");
	return v-nl+NR_END;
}

int *ivector(long nl, long nh)
/* allocate an int vector with subscript range v[nl..nh] */
{
	int *v;

	v=(int *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(int)));
	if (!v) nrerror("allocation failure in ivector()");
	return v-nl+NR_END;
}

unsigned char *cvector(long nl, long nh)
/* allocate an unsigned char vector with subscript range v[nl..nh] */
{
	unsigned char *v;

	v=(unsigned char *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(unsigned char)));
	if (!v) nrerror("allocation failure in cvector()");
	return v-nl+NR_END;
}

unsigned long *lvector(long nl, long nh)
/* allocate an unsigned long vector with subscript range v[nl..nh] */
{
	unsigned long *v;

	v=(unsigned long *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(long)));
	if (!v) nrerror("allocation failure in lvector()");
	return v-nl+NR_END;
}

double *dvector(long nl, long nh)
/* allocate a double vector with subscript range v[nl..nh] */
{
	double *v;

	v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));
	if (!v) nrerror("allocation failure in dvector()");
	return v-nl+NR_END;
}

float **matrix(long nrl, long nrh, long ncl, long nch)
/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	float **m;

	/* allocate pointers to rows */
	m=(float **) malloc((size_t)((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;

	/* allocate rows and set pointers to them */
	m[nrl]=(float *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

double **dmatrix(long nrl, long nrh, long ncl, long nch)
/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	double **m;

	/* allocate pointers to rows */
	m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;

	/* allocate rows and set pointers to them */
	m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

int **imatrix(long nrl, long nrh, long ncl, long nch)
/* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	int **m;

	/* allocate pointers to rows */
	m=(int **) malloc((size_t)((nrow+NR_END)*sizeof(int*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;


	/* allocate rows and set pointers to them */
	m[nrl]=(int *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(int)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

float **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,
	long newrl, long newcl)
/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */
{
	long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;
	float **m;

	/* allocate array of pointers to rows */
	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure in submatrix()");
	m += NR_END;
	m -= newrl;

	/* set pointers to rows */
	for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

float **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch)
/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
and ncol=nch-ncl+1. The routine should be called with the address
&a[0][0] as the first argument. */
{
	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;
	float **m;

	/* allocate pointers to rows */
	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure in convert_matrix()");
	m += NR_END;
	m -= nrl;

	/* set pointers to rows */
	m[nrl]=a-ncl;
	for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;
	/* return pointer to array of pointers to rows */
	return m;
}

float ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh)
/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */
{
	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;
	float ***t;

	/* allocate pointers to pointers to rows */
	t=(float ***) malloc((size_t)((nrow+NR_END)*sizeof(float**)));
	if (!t) nrerror("allocation failure 1 in f3tensor()");
	t += NR_END;
	t -= nrl;

	/* allocate pointers to rows and set pointers to them */
	t[nrl]=(float **) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float*)));
	if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");
	t[nrl] += NR_END;
	t[nrl] -= ncl;

	/* allocate rows and set pointers to them */
	t[nrl][ncl]=(float *) malloc((size_t)((nrow*ncol*ndep+NR_END)*sizeof(float)));
	if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");
	t[nrl][ncl] += NR_END;
	t[nrl][ncl] -= ndl;

	for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;
	for(i=nrl+1;i<=nrh;i++) {
		t[i]=t[i-1]+ncol;
		t[i][ncl]=t[i-1][ncl]+ncol*ndep;
		for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;
	}

	/* return pointer to array of pointers to rows */
	return t;
}

void free_vector(float *v, long nl, long nh)
/* free a float vector allocated with vector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_ivector(int *v, long nl, long nh)
/* free an int vector allocated with ivector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_cvector(unsigned char *v, long nl, long nh)
/* free an unsigned char vector allocated with cvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_lvector(unsigned long *v, long nl, long nh)
/* free an unsigned long vector allocated with lvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_dvector(double *v, long nl, long nh)
/* free a double vector allocated with dvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_matrix(float **m, long nrl, long nrh, long ncl, long nch)
/* free a float matrix allocated by matrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch)
/* free a double matrix allocated by dmatrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_imatrix(int **m, long nrl, long nrh, long ncl, long nch)
/* free an int matrix allocated by imatrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_submatrix(float **b, long nrl, long nrh, long ncl, long nch)
/* free a submatrix allocated by submatrix() */
{
	free((FREE_ARG) (b+nrl-NR_END));
}

void free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch)
/* free a matrix allocated by convert_matrix() */
{
	free((FREE_ARG) (b+nrl-NR_END));
}

void free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,
	long ndl, long ndh)
/* free a float f3tensor allocated by f3tensor() */
{
	free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));
	free((FREE_ARG) (t[nrl]+ncl-NR_END));
	free((FREE_ARG) (t+nrl-NR_END));
}

