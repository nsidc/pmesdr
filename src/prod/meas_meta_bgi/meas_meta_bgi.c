/* (c) copyright 2014 David G. Long, Brigham Young University */
/*****************************************************************
  Filename:  meas_meta_bgi.c    MEaSURES project

  program to generate Backus-Gilbert Inversion (bgi) images from
  setup files generated by the ssmi_meta_setup program

  Written by DGL at BYU 02/25/2014 + modified from ssmi_meta_bgi.c
  Revised by DGL at BYU 05/16/2015 + use intermediate dump file output
  Revised by DGL at BYU 06/21/2014 + modified gain thresholding and response rejection
  Revised by DGL at BYU 07/04/2014 + removed extra memory array allocations, reduced redundant computation of z
  Revised by DGL at BYU 07/24/2014 + changed default parameter settings, measurements that span horizontal edge
  Revised by DGL at BYU 08/02/2014 + folded in changes by Brodzik
  Revised by DGL at BYU 08/16/2014 + revised error handling, optional INFOfile out

******************************************************************/

#include <stdlib.h>
#include <stdio.h>
#ifdef JANUSicc
#include <mathimf.h>
#else
#include <math.h>
#endif

#include <string.h>
#include <time.h>
#include <netcdf.h>

#include "sir3.h"

#define NRANSI
#include "nr.h"
#include "nrutil.h"

#define VERSION 2.1

#define file_savings 1.00     /* measurement file savings ratio */
#define REL_EOF   2           /* fseek relative to end of file */
#define REL_BEGIN 0           /* fseek relative to end of file */

#define INFOFILE 1            /* define to create info file, undefine to not create */
#undef INFOFILE               /* do not create info file */

#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))

/****************************************************************************/

/* some variables and their default values */

float a_init=180.0;           /* initial A (TB) value */
int   nits=30;                /* number of SIR iterations */
char  sensor_in[40];          /* sensor description string */
int   MAXFILL=1000;           /* maximum number of pixels in response */
int   HASAZANG=0;             /* azimuth angle data not included */
int   HS=20;                  /* measurement headersize in bytes */

/* the following BG parameters are subjectively set */

double bgi_gamma=2.6703537554;    /*0.85*3.1415926535;/* default BGI gamma parameter */
float delta2=1.0;                 /* default BGI assumed noise variance */
float omega=0.001;                /* BGI scale factor (fixed)*/
float ithres=0.125;               /* default minimum gain threshold */
int Nsize=0;                      /* (built into the code) */
float wscale=0.001;  /* pattern scale coversion factor int->float */

/****************************************************************************/

void eprintf(char *s)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s);
  fflush(stdout);
  fprintf(stderr,s);
  fflush(stderr);
}

void eprintfi(char *s, int a)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s,a);
  fflush(stdout);
  fprintf(stderr,s,a);
  fflush(stderr);
}

void eprintfc(char *s, char *a)
{ /* print to both stdout and stderr to catch errors */
  fprintf(stdout,s,a);
  fflush(stdout);
  fprintf(stderr,s,a);
  fflush(stderr);
}


/* function prototypes */

void count_hits(int count, int fill_array[], short int response_array[], float ithres, int cnt[], int *mdim, int nsx);

void make_indx(int nmax, int count, int fill_array[], short int response_array[], float ithres, char **indx, char * pointer);

void Ferror(int i);

void filter(float *val, int size, int opt, int nsx, int nsy, float
	    *temp, float thres);

void no_trailing_blanks(char *s);

char *addpath(char *outpath, char *name, char *temp);

int nc_open_file_write_head(char *inter_name, int *ncid, int nsx, int nsy, int iopt, 
		 float ascale, float bscale, float a0, float b0, float xdeg, float ydeg, 
		 int isday, int ieday, int ismin, int iemin, int iyear, int iregion, int ipol, 
		 int nsx2, int nsy2, int non_size_x, int non_size_y, float ascale2, float bscale2, 
		 float a02, float b02, float xdeg2, float ydeg2,
			    float a_init, int ibeam, int nits, int median_flag, int nout); 
   
int add_string_nc(int ncid, char *name, char *str, int maxc);

int add_float_array_nc(int ncid, char *name, float *val, int nsx, int nsy, float anodata_A);

int nc_close_file(int ncid);

void check_err(const int stat, const int line, const char *file);

/****************************************************************************/

/* global array variables used for storing images*/

float *a_val, *a_temp;
int *cnts;

/* other global variables */

FILE *imf, *omf;
long int nspace;

/****************************************************************************/

/* main program */

int main(int argc, char **argv)
{

  char *file_in;
  char outpath[150];

  float latl, lonl, lath, lonh;
  char regname[11], *s;
  int dumb, nrec, ncnt, i, j, m, nsize;
  long int nls, nbyte;
  float ratio;
  char *space, *store, *store2, *last_store;
  float tbval;
  int count, iadd, end_flag;
  char *x;
  int irecords;
  int non_size_x, non_size_y, nsx2, nsy2, ix, iy;
  float xdeg2, ydeg2, ascale2, bscale2, a02, b02;

 /* define no-data values */
  float anodata_A=0.0;

  int Nfiles_out=1;  

  int nsx, nsy, iyear, isday, ismin, ieday, iemin;
  int iregion, ipol, iopt;  
  char crproc[101], crtime[29];
  float xdeg, ydeg, ascale, bscale, a0, b0;

  time_t tod;

  int its, irec, keep;
  float amin;

  char a_name[100], info_name[100], line[100];

  char inter_name[250];
  int ncid, ncerr;

  long head_len;
  int errors = 0;

  int median_flag = 0;  /* default: no median filter */
  int ibeam = 0;
 
  int nmax, mdim, mdim2, mwork, k, dx, dy, i1, j1;
  int *ix0, *iy0, *ind;
  char **indx;
  float sum, **z, **zc, *u, *v, *u1, *v1, *c, *work, *tb2, *patarr;
  float p,value1, value2;
  int *fill_array;
  short int *weight_array;

/* begin program */  

  printf("BYU SSM/I meta BG program: C version %f\n",VERSION);

  if (argc < 3) {
    printf("\nusage: %s setup_in outpath gamma delta2 ithres\n\n",argv[0]);
    printf(" input parameters:\n");
    printf("   setup_in = input setup file\n");
    printf("   outpath  = output path\n");
    printf("   gamma    = BGI gamma parameter\n");
    printf("   delta2   = BGI delta2 (noise variance)\n");
    printf("   ithres   = gain threshold (in normal space)\n");
    return(-1);
  }
  file_in=argv[1];

  imf = fopen(file_in,"r"); 
  if (imf == NULL) {
     eprintfc("ERROR: cannot open input setup file: %s\n",argv[1]); 
     exit(-1);
  }
 
  strncpy(outpath,"./",250); /* default output path */  

  if (argc > 2) sscanf(argv[2],"%s",outpath);
  if (argc > 3) sscanf(argv[3],"%lf",&bgi_gamma);
  if (argc > 4) sscanf(argv[4],"%f",&delta2);
  if (argc > 5) sscanf(argv[5],"%f",&ithres);

  printf("BGI options: omega=%f gamma=%f delta2=%f gain thres=%f\n",omega, bgi_gamma, delta2, ithres);

  /* get input file size */
  fseek(imf, 0L, REL_EOF);
  nls=ftell(imf);
  rewind(imf);

/* read setup file header info 
   note: setup file is written by a fortran program and so has extra
         record information.  This must be skipped when reading */

/*   read (50) irecords  ! Get number of measurement records in file */

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(0); /* record header */
   if (fread(&irecords,sizeof(int)  , 1, imf) == 0) Ferror(1);
   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(2); /* record trailer */

/*   read (50) nsx,nsy,ascale,bscale,a0,b0,xdeg,ydeg ! Get header info */

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(3); /* record header */
   if (fread(&nsx,   sizeof(int)  , 1, imf) == 0) Ferror(4);
   if (fread(&nsy,   sizeof(int)  , 1, imf) == 0) Ferror(5);
   if (fread(&ascale,sizeof(float), 1, imf) == 0) Ferror(6);
   if (fread(&bscale,sizeof(float), 1, imf) == 0) Ferror(7);
   if (fread(&a0,    sizeof(float), 1, imf) == 0) Ferror(8);
   if (fread(&b0,    sizeof(float), 1, imf) == 0) Ferror(9);
   if (fread(&xdeg,  sizeof(float), 1, imf) == 0) Ferror(10);
   if (fread(&ydeg,  sizeof(float), 1, imf) == 0) Ferror(11);

   if (fread(&dumb,  sizeof(int)  , 1, imf) == 0) Ferror(12); /* record trailer */

/*        read (50) dstart,dend,mstart,mend,year,regnum,projt,npol,
     $                  latl,lonl,lath,lonh,regname */

   if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(21);
   if (fread(&isday,  sizeof(int),   1, imf) == 0) Ferror(22);
   if (fread(&ieday,  sizeof(int),   1, imf) == 0) Ferror(23);
   if (fread(&ismin,  sizeof(int),   1, imf) == 0) Ferror(24);
   if (fread(&iemin,  sizeof(int),   1, imf) == 0) Ferror(25);
   if (fread(&iyear,  sizeof(int),   1, imf) == 0) Ferror(26);
   if (fread(&iregion,sizeof(int),   1, imf) == 0) Ferror(27);
   if (fread(&iopt ,  sizeof(int),   1, imf) == 0) Ferror(28);
   if (fread(&ipol,   sizeof(int),   1, imf) == 0) Ferror(29);
   if (fread(&latl,   sizeof(float), 1, imf) == 0) Ferror(30);
   if (fread(&lonl,   sizeof(float), 1, imf) == 0) Ferror(31);
   if (fread(&lath,   sizeof(float), 1, imf) == 0) Ferror(32);
   if (fread(&lonh,   sizeof(float), 1, imf) == 0) Ferror(33);
   if (fread(regname, sizeof(char), 10, imf) == 0) Ferror(34);
   regname[10]='\0';
   if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(35);

/*   read (50) nsx2,nsy2,non_size_x,non_size_y,
     $          ascale2,bscale2,a02,b02,xdeg2,ydeg2 */

   if (fread(&dumb,   sizeof(int)  , 1, imf) == 0) Ferror(43);/* record header */
   if (fread(&nsx2,   sizeof(int)  , 1, imf) == 0) Ferror(44);
   if (fread(&nsy2,   sizeof(int)  , 1, imf) == 0) Ferror(45);
   if (fread(&non_size_x,sizeof(int)  , 1, imf) == 0) Ferror(46);
   if (fread(&non_size_y,sizeof(int)  , 1, imf) == 0) Ferror(47);
   if (fread(&ascale2,sizeof(float), 1, imf) == 0) Ferror(48);
   if (fread(&bscale2,sizeof(float), 1, imf) == 0) Ferror(49);
   if (fread(&a02,    sizeof(float), 1, imf) == 0) Ferror(50);
   if (fread(&b02,    sizeof(float), 1, imf) == 0) Ferror(51);
   if (fread(&xdeg2,  sizeof(float), 1, imf) == 0) Ferror(52);
   if (fread(&ydeg2,  sizeof(float), 1, imf) == 0) Ferror(53);

   if (fread(&dumb,   sizeof(int)  , 1, imf) == 0) Ferror(54);/* record trailer */

   /* file header read completed, summarize */
   printf("\nInput file header info: '%s'\n",file_in);
   printf("  Year, day range: %d %d - %d\n",iyear,isday,ieday);
   printf("  Image size: %d x %d = %d   Projection: %d\n",nsx,nsy,nsx*nsy,iopt);
   printf("  Origin: %f,%f  Span: %f,%f\n",a0,b0,xdeg,ydeg);
   printf("  Scales: %f,%f  Pol: %d  Reg: %d\n",ascale,bscale,ipol,iregion);
   printf("  Region: '%s'   Records: %d\n",regname,irecords);
   printf("  Corners: LL %f,%f UR %f,%f\n",latl,lonl,lath,lonh);
   printf("  Grid size: %d x %d = %d  Scales %d %d\n",nsx2,nsy2,nsx2*nsy2,non_size_x,non_size_y);
   printf("  Grid Origin: %f,%f  Grid Span: %f,%f\n",a02,b02,xdeg2,ydeg2);
   printf("  Grid Scales: %f,%f\n",ascale2,bscale2);
   printf("\n");
   fflush(stdout);

   /* read output file names and misc variables

     In principle, these can be in variable order.  However, if standard
     program is used, order and number is known.  Most variables are info
     only, but some control the internal operations.
   */

   end_flag = 0;
   do {
     
     if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(70);
     if (fread(line,   sizeof(char), 100, imf) == 0) Ferror(71);
     if (fread(&dumb,   sizeof(int),   1, imf) == 0) Ferror(72);
     /* printf("line read '%s'\n",line); */

     if (strstr(line,"A_initialization") != NULL) {
       x = strchr(line,'=');
       a_init=  atof(++x) ;
       //printf("A_initialization of %f\n",a_init);
     }

     if (strstr(line,"Beam_code") != NULL) {
       x = strchr(line,'=');
       ibeam=atoi(++x);
       printf("Beam code %d\n",ibeam);
     }

     if (strstr(line,"Max_Fill") != NULL) {
       x = strchr(line,'=');
       MAXFILL=atoi(++x);
       //printf("Max fill %d\n",MAXFILL);
     }

     if (strstr(line,"Response_Multiplier") != NULL) {
       x = strchr(line,'=');
       //wscale=1.0/atoi(++x);
       printf("Wscale %f\n",wscale);
     }

     if (strstr(line,"Sensor") != NULL) {
       x = strchr(line,'=');
       strncpy(sensor_in,++x,40);
       no_trailing_blanks(sensor_in);
       printf("Sensor '%s'\n",sensor_in);
     }

     if ((x = strchr(line+4,' ')) != NULL) *x='\0'; /* truncate off any trailing spaces */

     if (strstr(line,"Median_flag") != NULL) {
       x = strchr(line,'=')+1;
       if (strstr(x,"T") != NULL || strstr(x,"t") != NULL)
	  median_flag=1;
       if (strstr(x,"F") != NULL || strstr(x,"f") != NULL)
	  median_flag=0;
       printf("Median flag: %d\n",median_flag);       
      }

     if (strstr(line,"Has_Azimuth_Angle") != NULL) {
       x = strchr(line,'=')+1;
       if (strstr(x,"T") != NULL || strstr(x,"t") != NULL) {
	 HASAZANG=1;
	 HS += 4;  /* increase read buffer size */
       }
       if (strstr(x,"F") != NULL || strstr(x,"f") != NULL)
	 HASAZANG=0;
       printf("Has azimuth angle: %d\n",HASAZANG);       
     }

     if (strstr(line,"SIRF_A_file") != NULL) {
       x = strchr(line,'=');
       strncpy(a_name,++x,100);
       no_trailing_blanks(a_name);
     }
     if (strstr(line,"Info_file") != NULL) {
       x = strchr(line,'=');
       strncpy(info_name,++x,100);
       no_trailing_blanks(info_name);
     }
      
     if (strstr(line,"End_header") != NULL) {
       end_flag = 1;
     }

   } while (end_flag == 0);

   printf("\n");
   printf("A output file: '%s'\n",a_name);
   printf("Info file: '%s'\n",info_name);
   printf("\n");

  /* generate output intermediate dump file name, open file, and dump info */
   sprintf(inter_name,"%s/%s_dump1.nc",outpath,info_name);
   ncerr=nc_open_file_write_head(inter_name, &ncid, nsx, nsy, iopt, 
				 ascale, bscale, a0, b0, xdeg, ydeg, 
				 isday, ieday, ismin, iemin, iyear, iregion, ipol, 
				 nsx2, nsy2, non_size_x, non_size_y, 
				 ascale2, bscale2, a02, b02, xdeg2, ydeg2,
				 a_init, ibeam, nits, median_flag, 
				 Nfiles_out); check_err(ncerr, __LINE__,__FILE__);

   /* add string information */
   ncerr=add_string_nc(ncid,"Region_name",regname,10); check_err(ncerr, __LINE__,__FILE__);
   ncerr=add_string_nc(ncid,"Sensor_name",sensor_in,40); check_err(ncerr, __LINE__,__FILE__);
   sprintf(crproc,"BYU MERS:meas_meta_bgi v1.0 g=%f d2=%f thres=%f",bgi_gamma,delta2,ithres);
   ncerr=add_string_nc(ncid,"Creator",crproc,101); check_err(ncerr, __LINE__,__FILE__); 
   (void) time(&tod);
   (void) strftime(crtime,28,"%X %x",localtime(&tod));
   ncerr=add_string_nc(ncid,"Creation_time",crtime,29); check_err(ncerr, __LINE__,__FILE__); 


   /* generate BG output name */
   s=strncpy(line,a_name,100);
   s=strchr(line,'.');
   if (s != NULL) *s ='\0';
   sprintf(a_name,"%s.bgi",line);

   /* add product file names */
   ncerr=add_string_nc(ncid,"bgi_name",a_name,100); check_err(ncerr, __LINE__,__FILE__);


   head_len = ftell(imf);
   printf("Input header file length %ld\n",head_len);
   nls=nls-head_len;

   fflush(stdout);

/* header read completed, now determine how much program memory to allocate */

  nspace = nls * file_savings;/* space to allocate for measurement storage */
  printf("  File size: %ld  Space allocated: %ld\n",nls,nspace);
  space = (char *) malloc(sizeof(char)*nspace);
  if (space == NULL) {
      eprintf("*** Inadequate memory for data file storage\n");
      exit(-1);
  }

/* allocate storage space for image and working array */

  nsize = nsx * nsy;
  
  a_val  = (float *) malloc(sizeof(float)*nsize);
  a_temp = (float *) malloc(sizeof(float)*nsize);
  cnts   = (int *) a_temp;  /* share storage space */

  if (a_val == NULL || a_temp == NULL) {
     eprintf("*** ERROR: inadequate memory for image working storage\n");
     exit(-1);
  }

   fflush(stdout);  

   /* initialize count array */

   for (i=0; i < nsize; i++)
     cnts[i]=0;
   mwork=0;

  /* with storage allocated, copy file into memory if selected */

  /* read measurement file into memory, 
			   storing only essential information  */

  nrec = 0;         /* number of meaurements in file */
  ncnt = 0;         /* number of useable measurements */
  nbyte = 0;        /* file size in bytes */
  store=space;      /* storage pointer */
  
  printf("Begin setup file copy into memory\n");
  while (fread(&dumb, sizeof(int), 1, imf) != 0) {

    /*	   read (50,err=500,end=500) tbval,ang,count,ktime,iadd,azi
	   read (50,err=500,end=500) (fill_array(i),i=1,count)
	   read (50,err=500,end=500) (response_array(i),i=1,count)
    */

     /*5 items at 4 bytes each: 20 bytes if no azimuth angle */
     /*6 items at 4 bytes each: 24 bytes if azimuth angle */
     if (nbyte+HS < nspace) {
       	if ((dumb=fread(store, sizeof(char), HS, imf)) != HS) {
          eprintfi(" *** Error reading input file data at 180 %d\n",dumb);
	  exit(-1);
        }
        if (fread(&dumb,sizeof(int), 1, imf) == 0) Ferror(100);

        tbval = *((float *) (store+0));
        /* ang   = *((float *) (store+4));  */
        count = *((int *)   (store+8));
	/*        ktime = *((int *)   (store+12)); */
        iadd  = *((int *)   (store+16));
	/* if (HASAZANG)
	   azang = *((float *) (store+20)); */

	if (count > MAXFILL) {
	  printf("*** Count error %d  record %d\n",count,nrec);
	  count=MAXFILL;	  
	}
	/*
	printf("ncnt %d  %f %f  count %d %d %d\n",ncnt,tbval,ang,count,ktime,iadd); 
	if (ncnt > 99) goto label; */

	/* if measurement is "valid" keep it by indexing counters 
           if not, new values will be stored over old values */

	keep=0;
	if (tbval < 350.0 && tbval > 50.0) { 
	  nbyte=nbyte+HS;
	  store=store+HS;
	  ncnt++;
	  keep=1;
	}

	/* read fill_array pixel indices */
	if (nbyte+count*4 < nspace) {
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(110);
	   if (fread(store, sizeof(int), count, imf) != count) {
	      eprintf(" *** Error reading input file data at 111\n");
	      /* exit(-1); */
	      goto label;
	   }

	   if (keep == 1) {
	     last_store=store;
	     nbyte=nbyte+count*4;
	     store=store+count*4;
	   }
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(112);
	} else {
	   eprintfi(" *** out of storage space 1 *** %d\n",ncnt);
	   fprintf(stderr," *** out of storage space 1 *** %d %ld %ld\n",ncnt,nbyte,nspace);
	   exit(-1);
	}

	/* read response_array weights */
	if (nbyte+count*2 < nspace) {
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(1101);
	   if (fread(store, sizeof(short int), count, imf) != count) {
	      eprintf(" *** Error reading input file data at 1111\n");
	      goto label;
	   }
	   if (keep == 1) {
	     count_hits(count, (int *) last_store, (short int *) store, ithres, cnts, &m, nsx);
	     if (m > mwork) mwork = m;
	     if (count % 2 == 1) count=count+1;  /* ensure storage of next record on a 4byte word boundary */
	     nbyte=nbyte+count*2;
	     store=store+count*2;
	   }
	   if (fread(&dumb, sizeof(int), 1, imf) == 0) Ferror(1121);
	} else {
	   eprintfi(" *** out of storage space 2 *** %d\n",ncnt);
	   fprintf(stderr," *** out of storage space 2 *** %d %ld %ld\n",ncnt,nbyte,nspace);
	   exit(-1);
	}

	nrec++;

     } else {
       eprintfi(" *** out of storage space 3 *** %d\n",ncnt);
       fprintf(stderr," *** out of storage space 3 *** %d %ld\n",ncnt,nspace);
       exit(-1);
     }
    }
  label:
  fclose(imf);


/* print measurement file storage requirements */

  ratio=100.0 * (float) nbyte / (float) nls;
  printf("  Input file read into ram\n");
  printf("  Total storage used: %d %d recs = %ld of %ld (%.1f%% %.1f%%)\n",
	 nrec,ncnt,nbyte,nspace,ratio,100.0*file_savings);
  fflush(stdout);


  /* determine maximum hits */

  nmax=0;
  for (i=0; i< nsize; i++)
    if (cnts[i] > nmax) nmax=cnts[i];
  printf("\nMaximum hits above threshold: %d  max size: %d  thres %f\n",nmax, mwork, ithres);
  mdim = mwork * 2+1;
 
  /* BG processing */

  /* allocate index array and BGI working arrays*/

  indx = (char **) malloc(sizeof(char *)*nsize*nmax);
  z = matrix(1,nmax,1,nmax);
  zc = matrix(1,nmax,1,nmax);
  u = vector(1,nmax);
  u1 = vector(1,nmax);
  v = vector(1,nmax); 
  v1 = vector(1,nmax); 
  ind = ivector(1,nmax);
  work = vector(1,nmax);
  c = vector(1,nmax);
  tb2 = vector(1,nmax);
  patarr = (float *) malloc(sizeof(float)*mdim*mdim*nmax);
  ix0 = (int *) malloc(sizeof(int)*(nmax+1));
  iy0 = (int *) malloc(sizeof(int)*(nmax+1));
  if (indx == NULL || z == NULL || u == NULL || v == NULL || c == NULL
      || zc == NULL || u1 == NULL || v1 == NULL || ind == NULL
      || work == NULL || tb2 == NULL || patarr == NULL || ix0 == NULL || iy0 == NULL) {
    printf("*** error allocating BGI work arrays \n");
    exit(-1);
  }

  /* create index array */

  for (i=0; i< nsize; i++)
    for (j=0; j< nmax; j++)
      indx[i*nmax+j] = NULL;

  store=space;
  for (irec = 0; irec < ncnt; irec++) {
    last_store=store;
    count = *((int *)   (store+8));
    iadd = *((int *) (store+16));
    store = store+HS;
    store2 = store + 4*count;
  
    make_indx(nmax, count, (int *) store, (short int *) store2, ithres, indx, last_store);
    store = store+4*count;
    store = store+2*count;
    if (count % 2 == 1) store=store+2;  /* ensure word boundary */
  }

  printf("Index array created %d %d\n",nsize,ncnt);
  
  
/* Begin BGI processing */

  mdim2=mdim/2+1;

  for (its=0; its < nsize; its++) {   /* for each pixel */
    *(a_val+its) = anodata_A;

    /* print progress */
    if ((its % nsx) == nsx/2  && (its/nsx) % 5 == 0) 
      printf("Processing row %d of %d  %f\n",its/nsx,nsy,amin);
    
    if (cnts[its] > 0) {
      m=0;  /* number of valid measurements */
      for (k=0; k < nmax; k++) {  /* for possible each measurement */
	store = indx[its*nmax + k];
	if (store != NULL) {        /* get measurement info from memory */
	  tbval = *((float *) (store+0));
	  count = *((int *)   (store+8));
	  iadd  = *((int *)  (store+16));
	  iadd = (iadd > 0 ? iadd : -iadd) -1;
	  /* if (HASAZANG)
	     azang = *((float *) (store+20)); */

	  store = store+HS;
	  fill_array = (int *) store;
	  store = store + 4*count;
	  weight_array = (short int *) store;
	  /*
	  printf("at %d %d %d %d\n",its,m,k,count);
	  for (i=0; i < count; i++)
	    printf("  %d %d %d\n",i,fill_array[i],weight_array[i]);
	  */
	  m++;
	  v[m] = 0.0000001;  /* a very small, non-zero value */
	  sum = 0.0;
	  for (i=0; i < count; i++) 
	    if (fill_array[i]>0) {
	      if (fill_array[i]-1 == its) 
		v[m] = weight_array[i]*wscale;
	      sum += weight_array[i]*wscale;
	    }
	  tb2[m] = tbval;
	  if (sum > 0.0) v[m]=v[m]/sum;
	  u[m]=1.0;
	
	  ix0[m] = iadd % nsx;
	  iy0[m] = iadd / nsx;

	  for (i=0; i< mdim*mdim; i++)
	    patarr[i*nmax+m-1]=0.0;
	
	  for (i=0; i < count; i++) 
	    if (fill_array[i]>0) {
	      dx = (fill_array[i]-1) % nsx - ix0[m];
	      if (dx < -nsx/2) dx=dx+nsx; /* handle measurements that span horizontal image edge */
	      if (dx >  nsx/2) dx=dx-nsx; /* handle measurements that span horizontal image edge */
	      ix = dx + mdim2;
	      iy = (fill_array[i]-1) / nsx - iy0[m] + mdim2;
	      if (ix >= 0 && iy >= 0 && ix < mdim && iy < mdim)
		patarr[(iy*mdim+ix)*nmax+m-1]=weight_array[i]*wscale;
	      else
		printf("*** patarr error %d %d %d  %d\n",i,ix,iy,its);
	    }
	}
      }

      if (m > 0) {

	/* compute z matrix */
	for (i=1; i <= m; i++)
	  for (j=i; j <= m; j++) {
	    dx = ix0[i] - ix0[j];
	    dy = iy0[i] - iy0[j];
	    z[i][j] = 0.0;
	    sum=0.0;
	    for (i1=1; i1 <= mdim; i1++)
	      for (j1=1; j1 <= mdim; j1++) {
		ix=i1-dx;
		iy=j1-dy;
		if (ix > 0 && iy > 0 && ix <= mdim && iy <= mdim)
		  sum = sum + patarr[((j1-1)*mdim+i1-1)*nmax+i-1]*patarr[((iy-1)*mdim+ix-1)*nmax+j-1];
	      } 
	    z[i][j] = sum * cos(bgi_gamma) ;

	    if (i == j) z[i][j] =  z[i][j] + omega *  sin(bgi_gamma)  * delta2;

	    z[j][i] = z[i][j];
	    /*	    printf("in z %d %d %d %d %f %f\n",i,j,dx,dy,sum*cos(bgi_gamma),z[dx,dy]); */
	  }
	/*
	printf("z is: %d %d %f\n",m,m,omega * sin(bgi_gamma) * delta2);
	for (i=1;i<=m;i++) {
	  for (j=1;j<=m;j++)
	    printf("%f ",z[i][j]);
	  printf("\n");
	}
	*/

	/* Do LU decomposition */
	ludcmp(z,m,ind,&p);

	for (i=1;i<=m;i++) {
	  u1[i]=u[i];
	  v1[i]=v[i];
	  for (j=1;j<=m;j++)
	    zc[i][j] = z[i][j];
	}
      
      /* solve linear system z x = u [compute z^-1 u]  (u and z destroyed in process) */
	lubksb(z,m,ind,u1);

      /* comute u^t z^-1 u */
	value2 = 0.0;
	for (i=1; i <= m; i++)
	  value2 = value2 + u[i] * u1[i];

	for (i=1;i<=m;i++)
	  for (j=1;j<=m;j++)
	    z[i][j] = zc[i][j];

      /* solve linear system z x = v [compute z^-1 v]  (v and z destroyed in process) */
	lubksb(z,m,ind,v1);

      /* comute u^t z^-1 v */
	value1 = 0.0;
	for (i=1; i <= m; i++)
	  value1 = value1 + u[i] * v1[i];

      /* compute work vector */
	for (i=1; i <= m; i++)
	  work[i] =  cos(bgi_gamma) *v[i] + u[i] * (1.0 - cos(bgi_gamma)  * value1)/value2;
      
      /* solve linear system z c = work [compute z^-1 work]  (destroyed in process) */
	lubksb(zc,m,ind,work);
      
      /* compute BG pixel estimate value */
	sum = 0.0;
	for (i=1; i <= m; i++)
	  sum = sum + work[i] * tb2[i];
	a_val[its] = sum;
	/* set data to 600.0 if it is OOR */
       	if ( a_val[its] < 50.0 || a_val[its] > 350.0 ) {
	  a_val[its] = 600.0;
	}
	
	/*
	printf("one %d %d  %f %f %f\n",its,m,sum,value1,value2);
	for (i=1; i <= m; i++)
	  printf("%d %f %f %f %f %f %f\n",i,u[i],v[i],u1[i],v1[i],work[i],tb2[i]);
	*/
	amin=a_val[its];
	
      } else /* pixel not hit, set its value to the default nodata value */
	a_val[its] = anodata_A;
    } 
  }

  printf("\nMaximum hits above threshold: %d  max size: %d  thres %f\n",nmax,mdim, ithres);

  if (median_flag) { /* median filter image */
    printf("Applying Median Filter to BG image result\n");    
    filter(a_val, 5, 0, nsx, nsy, a_temp, anodata_A);  /* 5x5 modified median filter */
  }
  

  /* output image file */

  printf("\n"); 
  if ( NC_NOERR != ( ncerr=add_float_array_nc(ncid,"bgi_image",a_val,nsx,nsy,anodata_A ) ) ) {
    errors++;
    eprintfc("Error dumping A BGI '%s'. \n", a_name );
  } else {
    printf("Dumped A BGI '%s'. \n", a_name );
  }

  ncerr=nc_close_file(ncid); check_err(ncerr, __LINE__,__FILE__);
  printf("\nFinished writing dump file: %s\n",inter_name);  

  if (errors == 0) {
    printf("No errors encountered\n");
#ifdef INFOFILE
    /* write out info file if processing is completed successfully */
    omf = fopen(info_name,"a"); 
    if (omf == NULL) {
      eprintfc("ERROR: cannot open info file: '%s'\n",info_name); 
    } else {
      fprintf(omf,"BG Processing of '%s' successfully completed\n",file_in);
      fprintf(omf,"A output file: '%s'\n",a_name);
      fclose(omf);
    }
#endif
  } else
    printf("Processing errors encountered\n");
  
  /* end of program */

  /* free malloc'ed memory (not strictly necessary, but good to be explicit) */
  free(space);
  free(a_val);
  free(a_temp);

  return(errors);
}


/* ***************** support routines **************** */

void count_hits(int count, int fill_array[], short int response_array[], float ithres, int cnt[], int *mdim, int nsx)
{
  register int i,n,m,x,y,xx,yx,xn,yn;
  int mpeak=-1;  

  /* find peak response of measurement*/
  for (i=0; i < count; i++) {      
    m=response_array[i];
    if (m > mpeak) mpeak=m;
  }
  /* compute (local) threshold based on peak response */
  mpeak=ithres*mpeak;

  /* find minimum size bounding box */
  yx=xx=0;
  yn=xn=99999999;
  for (i=0; i < count; i++) {
    n=fill_array[i]-1;
    m=response_array[i];
    if (m >= mpeak) {
      (cnt[n])++;
      x = n % nsx;
      y = n / nsx;
      xx = max(x,xx);
      yx = max(y,yx);
      xn = min(x,xn);
      yn = min(y,yn);
    } else { /* mark response values not to be used since they are below cutoff threshold */
      fill_array[i]=0;
      response_array[i]=0.0;      
    }
  }
  if (xx-xn+1 < nsx/2) /* check horizontal measurement span */
    x=xx-xn+1; /* horizontal span */
  else
    x=0;      /* do not consider horiznotal span of measurements that cross horizontal boundaries */
  y=yx-yn+1;  /* vertical span */
  *mdim=max(x,y);
}

void make_indx(int nmax, int count, int fill_array[], short int response_array[], float ithres, char **indx, char *pointer)
{
  static int i,j,m,n,mpeak=-1;

  /* find peak response of measurement*/
  for (i=0; i < count; i++)
    if (fill_array[i] > 0) {
      m=response_array[i];
      if (m > mpeak) mpeak=m;
    }
  /* compute (local) threshold based on peak response */
  mpeak=ithres*mpeak;

  for (i=0; i < count; i++) 
    if (fill_array[i] > 0) {
      n=fill_array[i]-1;
      m=response_array[i];
      if (m >= ithres) {
	j = 0;
	while (j < nmax && indx[n*nmax+j] != NULL) j++;
	if (j < nmax) indx[n*nmax+j]=pointer;
      }
    }  
}



/* modified median or smoothing filter routine */

float median(float *array, int count);

void filter(float *val, int size, int mode, int nsx, int nsy, 
	    float *temp, float thres)
{
  float array[100], total;
  int i,j,x,y,size2,count,x1,x2,y1,y2;
  
  if ((size % 2) == 0) size=size+1;   /* force window size odd */
  size2 = (size-1)/2;                 /* window center */

  for (x=1; x<= nsx; x++)
    for (y=1; y<= nsy; y++) {
      count=0;
      y1=max(y-size2,1);
      y2=min(y+size2,nsy);
      x1=max(x-size2,1);
      x2=min(x+size2,nsx);
      for (i=x1; i <= x2; i++)
	for (j=y1; j <= y2; j++)
	  if (*(val+i+(j-1)*nsx-1) > thres) {
	    array[count]=*(val+i+(j-1)*nsx-1);
	    count++;
	  };
      
      if (count > 0 && *(val+x+(y-1)*nsx-1) > thres) {
	if (mode == 0)  /* Mode 0 = median */
	  *(temp+(y-1)*nsx+x-1) = median(array,count);
	else {		/* Mode 1 = average */
	  total=0.0;
	  for (i=0; i<count; i++)
	    total=total+array[i];
	  *(temp+(y-1)*nsx+x-1) = total/count;
	}
      } else
	*(temp+(y-1)*nsx+x-1) = thres;
    };
  
  for (i=0; i < nsx*nsy; i++) {
    *(val+i) = *(temp+i);
    *(temp+i)=0.0;
  }
  return;
}

/* compute modified median of an array of values */

float median(float array[], int count)
{
  int i,j;
  float temp;

  for (i=count; i >= 2; i--)
    for (j=1; j <= i-1; j++)
      if (array[i-1] < array[i-j-1]) {
	temp=array[i-1];
	array[i-1]=array[i-j-1];
	array[i-j-1]=temp;
      };
  
  temp=array[count/2];

  if (array[count-2]-array[1] < 0.25 && count > 5) {
    temp=0.0;
    for (i=count/2-1; i <= count/2+3; i++)
      temp=temp+array[i-1];
    temp=temp/5.0;
  }
  return(temp);
}



void Ferror(int i)
{
  fprintf(stdout,"*** Error reading input file at %d ***\n",i);
  fprintf(stderr,"*** Error reading input file at %d ***\n",i);
  fflush(stdout);
  fflush(stderr);
  return;
  /* exit(-1); */
}



void no_trailing_blanks(char *s)
{  /* remove trailing blanks (spaces) from string */
  int n=strlen(s);
  
  while (n > 0) {
    if (s[n] != ' ' && s[n] != '\0') return;
    if (s[n] == ' ') s[n] = '\0';
    n--;
  }
  return;
}

char *addpath(char *outpath, char *name, char *temp)
{ /* append path to name, return pointer to temp */
  sprintf(temp,"%s/%s",outpath,name);
  return(temp);  
}

/****************************************************************************/

/* Numerical Recipes routines */

void lubksb(float **a, int n, int *indx, float b[])
{
	int i,ii=0,ip,j;
	float sum;

	for (i=1;i<=n;i++) {
		ip=indx[i];
		sum=b[ip];
		b[ip]=b[i];
		if (ii)
			for (j=ii;j<=i-1;j++) sum -= a[i][j]*b[j];
		else if (sum) ii=i;
		b[i]=sum;
	}
	for (i=n;i>=1;i--) {
		sum=b[i];
		for (j=i+1;j<=n;j++) sum -= a[i][j]*b[j];
		b[i]=sum/a[i][i];
	}
}

#define TINY 1.0e-20;

void ludcmp(float **a, int n, int *indx, float *d)
{
	int i,imax,j,k;
	float big,dum,sum,temp;
	float *vv;

	vv=vector(1,n);
	*d=1.0;
	for (i=1;i<=n;i++) {
		big=0.0;
		for (j=1;j<=n;j++)
			if ((temp=fabs(a[i][j])) > big) big=temp;
		if (big == 0.0) nrerror("Singular matrix in routine ludcmp");
		vv[i]=1.0/big;
	}
	for (j=1;j<=n;j++) {
		for (i=1;i<j;i++) {
			sum=a[i][j];
			for (k=1;k<i;k++) sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
		}
		big=0.0;
		for (i=j;i<=n;i++) {
			sum=a[i][j];
			for (k=1;k<j;k++)
				sum -= a[i][k]*a[k][j];
			a[i][j]=sum;
			if ( (dum=vv[i]*fabs(sum)) >= big) {
				big=dum;
				imax=i;
			}
		}
		if (j != imax) {
			for (k=1;k<=n;k++) {
				dum=a[imax][k];
				a[imax][k]=a[j][k];
				a[j][k]=dum;
			}
			*d = -(*d);
			vv[imax]=vv[j];
		}
		indx[j]=imax;
		if (a[j][j] == 0.0) a[j][j]=TINY;
		if (j != n) {
			dum=1.0/(a[j][j]);
			for (i=j+1;i<=n;i++) a[i][j] *= dum;
		}
	}
	free_vector(vv,1,n);
}
#undef TINY

/* CAUTION: This is the ANSI C (only) version of the Numerical Recipes
   utility file nrutil.c.  Do not confuse this file with the same-named
   file nrutil.c that is supplied in the 'misc' subdirectory.
   *That* file is the one from the book, and contains both ANSI and
   traditional K&R versions, along with #ifdef macros to select the
   correct version.  *This* file contains only ANSI C.               */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#define NR_END 1
#define FREE_ARG char*

void nrerror(char error_text[])
/* Numerical Recipes standard error handler */
{
	fprintf(stderr,"Numerical Recipes run-time error...\n");
	fprintf(stderr,"%s\n",error_text);
	fprintf(stderr,"...now exiting to system...\n");
	exit(1);
}

float *vector(long nl, long nh)
/* allocate a float vector with subscript range v[nl..nh] */
{
	float *v;

	v=(float *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(float)));
	if (!v) nrerror("allocation failure in vector()");
	return v-nl+NR_END;
}

int *ivector(long nl, long nh)
/* allocate an int vector with subscript range v[nl..nh] */
{
	int *v;

	v=(int *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(int)));
	if (!v) nrerror("allocation failure in ivector()");
	return v-nl+NR_END;
}

unsigned char *cvector(long nl, long nh)
/* allocate an unsigned char vector with subscript range v[nl..nh] */
{
	unsigned char *v;

	v=(unsigned char *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(unsigned char)));
	if (!v) nrerror("allocation failure in cvector()");
	return v-nl+NR_END;
}

unsigned long *lvector(long nl, long nh)
/* allocate an unsigned long vector with subscript range v[nl..nh] */
{
	unsigned long *v;

	v=(unsigned long *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(long)));
	if (!v) nrerror("allocation failure in lvector()");
	return v-nl+NR_END;
}

double *dvector(long nl, long nh)
/* allocate a double vector with subscript range v[nl..nh] */
{
	double *v;

	v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));
	if (!v) nrerror("allocation failure in dvector()");
	return v-nl+NR_END;
}

float **matrix(long nrl, long nrh, long ncl, long nch)
/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	float **m;

	/* allocate pointers to rows */
	m=(float **) malloc((size_t)((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;

	/* allocate rows and set pointers to them */
	m[nrl]=(float *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

double **dmatrix(long nrl, long nrh, long ncl, long nch)
/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	double **m;

	/* allocate pointers to rows */
	m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;

	/* allocate rows and set pointers to them */
	m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

int **imatrix(long nrl, long nrh, long ncl, long nch)
/* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */
{
	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
	int **m;

	/* allocate pointers to rows */
	m=(int **) malloc((size_t)((nrow+NR_END)*sizeof(int*)));
	if (!m) nrerror("allocation failure 1 in matrix()");
	m += NR_END;
	m -= nrl;


	/* allocate rows and set pointers to them */
	m[nrl]=(int *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(int)));
	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
	m[nrl] += NR_END;
	m[nrl] -= ncl;

	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

float **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,
	long newrl, long newcl)
/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */
{
	long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;
	float **m;

	/* allocate array of pointers to rows */
	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure in submatrix()");
	m += NR_END;
	m -= newrl;

	/* set pointers to rows */
	for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;

	/* return pointer to array of pointers to rows */
	return m;
}

float **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch)
/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
and ncol=nch-ncl+1. The routine should be called with the address
&a[0][0] as the first argument. */
{
	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;
	float **m;

	/* allocate pointers to rows */
	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
	if (!m) nrerror("allocation failure in convert_matrix()");
	m += NR_END;
	m -= nrl;

	/* set pointers to rows */
	m[nrl]=a-ncl;
	for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;
	/* return pointer to array of pointers to rows */
	return m;
}

float ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh)
/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */
{
	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;
	float ***t;

	/* allocate pointers to pointers to rows */
	t=(float ***) malloc((size_t)((nrow+NR_END)*sizeof(float**)));
	if (!t) nrerror("allocation failure 1 in f3tensor()");
	t += NR_END;
	t -= nrl;

	/* allocate pointers to rows and set pointers to them */
	t[nrl]=(float **) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float*)));
	if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");
	t[nrl] += NR_END;
	t[nrl] -= ncl;

	/* allocate rows and set pointers to them */
	t[nrl][ncl]=(float *) malloc((size_t)((nrow*ncol*ndep+NR_END)*sizeof(float)));
	if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");
	t[nrl][ncl] += NR_END;
	t[nrl][ncl] -= ndl;

	for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;
	for(i=nrl+1;i<=nrh;i++) {
		t[i]=t[i-1]+ncol;
		t[i][ncl]=t[i-1][ncl]+ncol*ndep;
		for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;
	}

	/* return pointer to array of pointers to rows */
	return t;
}

void free_vector(float *v, long nl, long nh)
/* free a float vector allocated with vector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_ivector(int *v, long nl, long nh)
/* free an int vector allocated with ivector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_cvector(unsigned char *v, long nl, long nh)
/* free an unsigned char vector allocated with cvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_lvector(unsigned long *v, long nl, long nh)
/* free an unsigned long vector allocated with lvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_dvector(double *v, long nl, long nh)
/* free a double vector allocated with dvector() */
{
	free((FREE_ARG) (v+nl-NR_END));
}

void free_matrix(float **m, long nrl, long nrh, long ncl, long nch)
/* free a float matrix allocated by matrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch)
/* free a double matrix allocated by dmatrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_imatrix(int **m, long nrl, long nrh, long ncl, long nch)
/* free an int matrix allocated by imatrix() */
{
	free((FREE_ARG) (m[nrl]+ncl-NR_END));
	free((FREE_ARG) (m+nrl-NR_END));
}

void free_submatrix(float **b, long nrl, long nrh, long ncl, long nch)
/* free a submatrix allocated by submatrix() */
{
	free((FREE_ARG) (b+nrl-NR_END));
}

void free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch)
/* free a matrix allocated by convert_matrix() */
{
	free((FREE_ARG) (b+nrl-NR_END));
}

void free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,
	long ndl, long ndh)
/* free a float f3tensor allocated by f3tensor() */
{
	free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));
	free((FREE_ARG) (t[nrl]+ncl-NR_END));
	free((FREE_ARG) (t+nrl-NR_END));
}

