/* (c) copyright 2014 David G. Long, Brigham Young University */
/*****************************************************************
  Filename:  meas_meta_make.c

  generates SIR meta file for the MEaSUREs project

  translated to C by DGL at BYU 03/01/2014 from ssmi_meta_make3.f 
   note: while fortran was well-tested, not all C program options
   have been fully tested
  Modified by DGL at BYU 3/07/2014 + added EASE2 capability
  Modified by DGL at BYU 8/16/2014 + added error message when required environment variable not defined
  Modified by MAH at NSIDC 10/10/2014 - compile directive for Intel math library
  Modified by DGL at BYU 1/18/2015 + modified local time for LTOD, name scheme
  Modified by MAH at NSIDC 01/20/2015 - added DGL's changes into meas_meta_make.c for repo

******************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef JANUSicc
#include <mathimf.h>
#else
#include <math.h>
#endif
#include <time.h>

#include <sir3.h>
#include <cetb.h>

#define prog_version 1.2 /* program version */
#define prog_name "meas_meta_make"

#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))
#define mod(a,b) ((a) % (b))
#define abs(x) ((x) >= 0 ? (x) : -(x))

int nint(float r)
{
  int ret_val = r;
  if (ret_val - r > 0.5) ret_val--;
  if (r - ret_val > 0.5) ret_val++;
  return(ret_val);
}

#define TRUE 1
#define FALSE 0

/****************************************************************************/
/* default location of the SIR standard region definition */

char rname[] = "regiondef1.dat";  /* file defining region codes */

/********************************************************************/

/* function prototypes */

int get_region_parms( FILE *mout, FILE *jout, int argc, int *argn, char *argv[], 
		     char *mname, int F_num );

int get_file_names(FILE *mout, int argc, int *argn, char *argv[]);

/* declare specific map projection prototypes needed */

extern void ease2_map_info(int iopt, int isc, int ind, 
			   double *map_equatorial_radius_m, 
			   double *map_eccentricity, double *e2,
			   double *map_reference_latitude, 
			   double *map_reference_longitude, 
			   double *map_second_reference_latitude,
			   double *sin_phi1, double *cos_phi1, double *kz,
			   double *map_scale, int *bcols, int *brows, 
			   double *r0, double *s0, double *epsilon);

/****************************************************************************/
/* note: program is designed to be run from command line OR interactively 
*/


int main(int argc,char *argv[])
{
 
  char mname[256], line[1024];  
  time_t tod;
  char ltime[29];
  int argn=1;
  char platform[28];
  int Fn=0;
  cetb_platform_id F_num=CETB_NO_PLATFORM;
  FILE *mout, *jout;

  
  printf("MEaSures Meta_Make Program\nProgram: %s  Version: %f\n\n",prog_name,prog_version);

  if (argc < 8) {
    printf("\nusage: %s meta_name platform start_day stop_day year def in_list\n\n",argv[0]);
    printf(" input parameters:\n");
    printf("   meta_name   = meta file output name\n");
    printf("   platform    = name of the platform as cetb_platform_id (from cetb.h)\n");
    printf("   start_day   = start day\n");
    printf("   end_day     = end day\n");
    printf("   year        = year input\n");
    printf("   def         = region def file \n");
    printf("   in_list     = name of input file containing list of swath files\n\n");
    exit (-1);
  }

  /* get local time/date */
  (void) time(&tod);
  (void) strftime(ltime,28,"%X %x",localtime(&tod));

  /* get meta file name */
  sscanf(argv[argn],"%s",mname);
  printf("\nMetafile name: %s \n",mname);
  argn++;  

  /* get satellite number as a cetb_platform_id enum */
  sscanf(argv[argn],"%s",platform);
  argn++;
  /* decode platform number */
  while( Fn < (int)CETB_NUM_PLATFORMS ) {
    if ( 0 == strcmp( cetb_platform_id_name[Fn], platform ) ) {
	F_num = (cetb_platform_id)Fn;
	Fn = CETB_NUM_PLATFORMS;
    }
    Fn++;
  }
  if (F_num<=CETB_NO_PLATFORM || F_num>=CETB_NUM_PLATFORMS) {
    fprintf( stderr,"*** error decoding platform number: %s \n",platform );
    exit(-1);
  }
  printf("\nPlatform number: %s %s \n",platform,cetb_platform_id_name[F_num]);

  /* open output meta file and write header */
  printf("Opening meta output file %s\n",mname);
  mout=fopen(mname,"w");
  if (mout==NULL) {
    fprintf(stderr,"*** could not open output meta file: %s\n",mname);
    exit(-1);
  }
  fprintf(mout,"File=%s\n",mname);
  fprintf(mout,"Generated by=%s\n",prog_name);
  fprintf(mout,"Version=B%f\n",prog_version);
  fprintf(mout,"Meta_file_date=%s\n",ltime);
  fprintf(mout,"Sensor=%s\n",platform);

  /* get rest of input region parameters and write to file */
  get_region_parms( mout,jout,argc,&argn,argv,mname,F_num );

  /* get list of input files and save to file */
  get_file_names(mout,argc,&argn,argv);

  /* close output files */
  fclose(mout);
  printf("Finished writing meta file %s\n",mname);

  printf("\nAll done\n");

  exit( 0 );

}

  

/****************************************************************************/

int get_file_names(FILE *mout, int argc, int *argn, char *argv[])
{  /* read swath data files from list file and write to meta file */

  char lname[1000], line[1000];
  FILE *Lfile;
  int last=1, count=0;

  fprintf(mout,"Begin_input_file_list\n");

  /* get list file name */
  sscanf(argv[*argn],"%s",lname);
  (*argn)++;

  if (lname[0]!='\0') { /* read file names from input list file */
    /* open input list file */
    printf("Opening input list file %s\n",lname);
    Lfile=fopen(lname,"r");
    if (Lfile==NULL) {
      fprintf(stderr,"*** could not open input list file %s\n",lname);
      exit(-1);
    }

    last=1;
    do {
      /* read line of input list file and write to meta file */
      if (fgets(line,sizeof(line),Lfile) == NULL) {
	last=0;
	break;
      } else if (line[0]!='\0' && strlen(line)>1) {
	fprintf(mout," Input_file=%s",line);
	fprintf(stdout,"Input_file=%s",line);
	count++;
      } else
	last=0;

    } while (last);
    fclose(Lfile);

  } 

  fprintf(mout,"End_input_file_list\n");

  printf("Total number of input files: %d\n",count);
  return(0);
}
  


/* *********************************************************************** */

void getregdata(int regnum, int *iproj, int *dateline, float *latl, float *lonl,
		float *lath, float *lonh, char *regname)
{
  char line[180], *s, *p;  
  int regnum1=1, last;

  /* try to get environment variable */
  p=getenv("SIR_region");
  if (p==NULL) {
    printf("*** standard regions environment variable 'SIR_region' not defined!\n");    
    p=rname; /* use default if environment variable not available */
  }  

  FILE *rid=fopen(p,"r");
  if (rid==NULL) {
    fprintf(stderr,"*** could not open standard regions file %s\n",p);
    exit(-1);
  }

  /* skip first two input file header lines*/
  fgets(line,180,rid);
  fgets(line,180,rid);  

  last=1;
  do {
    /* read line of input file and check */
    if (fgets(line,180,rid) == NULL || regnum1==9999 || regnum1==0) {
      fprintf(stderr,"*** region %d not found in %s\n",regnum,p);
      exit(-1);
      last=0;
    }	
    sscanf(line,"%d %d %d %f %f %f %f %s\n",
	   &regnum1, iproj, dateline, latl, lonl, lath,  lonh, regname);
    s=strstr(line,regname);
    strncpy(regname,s,10);
    regname[10]='\0';
    /* printf("%s : %4d  %2d %2d %6.1f      %8.1f   %8.1f    %8.1f    '%s'\n",
       line,regnum1, *iproj, *dateline, *latl, *lonl, *lath,  *lonh, regname); */
    if (regnum1 == 9999 || regnum1 == 0) {
      fprintf(stderr,"*** region %d not found in %s\n",regnum,p);
      exit(-1);
      last=0;
    }	
    if (regnum1==regnum) {
      last=0;
      break;
    }
  } while (last);

  fclose(rid);
  return;  
}

/* utility routines */

int get_prompt_iarg(int argc, int *argn, char *argv[], char *prompt, int deflt)
{
  static char line[120];
  int val=deflt;  

  if (*argn > argc || argv[*argn] == NULL) {
    printf("%s ",prompt);
    fgets(line,sizeof(line),stdin);
    sscanf(line,"%d",&val);
  } else
    sscanf(argv[*argn],"%d",&val);
  (*argn)++;

  return(val);
}

float get_prompt_farg(int argc, int *argn, char *argv[], char *prompt, float deflt)
{
  static char line[120];
  float val=deflt;  

  if (*argn > argc || argv[*argn] == NULL) {
    printf("%s ",prompt);
    fgets(line,sizeof(line),stdin);
    sscanf(line,"%d",&val);
  } else
    sscanf(argv[*argn],"%f",&val);
  (*argn)++;

  return(val);
}

char *get_prompt_sarg(int argc, int *argn, char *argv[], char *prompt, char *deflt, char *buff, int blen)
{
  if (*argn > argc || argv[*argn] == NULL) {
    printf("%s ",prompt);
    fgets(buff,blen,stdin);
  } else
    strncpy(buff,argv[*argn],blen);
  (*argn)++;
  return(buff);
}


int get_prompt_larg(int argc, int *argn, char *argv[], char *prompt, int deflt)
{
  static char line[120], *s;
  int val=deflt;  

  if (*argn > argc || argv[*argn] == NULL) {
    printf("%s ",prompt);
    fgets(line,sizeof(line),stdin);
    s=line;
  } else
    s=argv[*argn];
  (*argn)++;

  if (s[0]=='T' || s[0]=='t' || s[0]=='Y' || s[0]=='y' || s[0]=='1')
    val=TRUE;
  if (s[0]=='F' || s[0]=='f' || s[0]=='N' || s[0]=='n' || s[0]=='0')
    val=FALSE;

  return(val);
}


/* routine that reads the input args and generates region definitions */

int get_region_parms( FILE *mout, FILE *jout, int argc, int *argn, char *argv[], 
		      char *mname, int F_num )
{
  /* define meta regions and file sections  and write to meta and job files */

  int err=0;  
  int negg=2; /* only do eggs */
  int sections=FALSE, nsection;
  char fnamel[1000], regname[11], reg[4], cpol, sen, cegg, chan;
  char TF[]={'F', 'T'};
  int dstart, dend, year, mstart, mend;
  float a_init, a_offset, b_init, b_weight, angle_ref, response_threshold;
  int nits, flatten, median_flag;
  char rfile[250];  
  int pfile;
  FILE *pid;
  int nregions, poleflag, dateline, iproj, regnum, iregion, ircnt;
  float latl, lonl, lath, lonh, deglat, deglon;
  int projt, nsx, nsy, xdim, ydim, nease;
  float ascale, bscale, xdeg, ydeg, a0, b0, aorglon, aorglat;
  float maplxlon, maprxlon, maplxlat, maprxlat, mapuylat, mapuylon, maplylat, maplylon;
  float x0, y0, lmostx, rmostx, umosty, lmosty;
  int toil, iasc, ibeam, ipolar;
  int non_size;
  float ascale_s, bscale_s, a0_s, b0_s, xdeg_s, ydeg_s;
  int nsx_s, nsy_s, nsect, nt, nsx2, nsy2;
  float a02, b02, xdeg2, ydeg2, ascale2, bscale2;
  int isection, ix, iy, ix1, iy1, ix2, iy2, jx1, jy1, jx2, jy2;
  int ix1g, iy1g, ix2g, iy2g, jx1g, jy1g, jx2g, jy2g;
  float temp, alpha, tsplit1, tsplit2;

  char a_name[120], b_name[120], i_name[120], j_name[120], c_name[120], p_name[120],
    v_name[120], e_name[120], lisname[120], aa_name[120], bb_name[120], non_aname[120], 
    non_bname[120], non_vname[120], grd_aname[120], grd_bname[120],grd_vname[120], 
    grd_iname[120], grd_jname[120], grd_pname[120], grd_cname[120], setname[120], *fname;

  double map_equatorial_radius_m,map_eccentricity, e2,
    map_reference_latitude, map_reference_longitude, 
    map_second_reference_latitude, sin_phi1, cos_phi1, kz,
    map_scale, r0, s0, epsilon;
  int bcols, brows, ind;
  
  fprintf(mout,"Egg_or_slice=%d\n",negg);

  /* read time period information */
  dstart=get_prompt_iarg(argc,argn,argv,"Enter starting day: ",1);
  dend=get_prompt_iarg(argc,argn,argv,"Enter ending day: ",1);
  year=get_prompt_iarg(argc,argn,argv,"Enter year (XXXX): ",1997);
  mstart=0;  /* start minute of day */
  mend=1440; /* end minute of day */

  printf("Input day range %d to %d year %d\n",dstart,dend,year);
  
  /* write to meta file */ 	
  fprintf(mout,"Begin_description\n");	 
  fprintf(mout," Start_Year=%5d\n",year);	
  fprintf(mout," Start_day=%4d\n",dstart);
  fprintf(mout," End_day=%4d\n",dend);
  fprintf(mout," Start_minute=%4d\n",mstart);
  fprintf(mout," End_minute=%4d\n",mend);

  /* set SIR imaging options */
  a_init=200.0;   /* initial TB valu for SIR */
  a_offset=0.0;   /* processing offset -- should be 0 */
  b_init=0.0;     /* initial slope of TB vs incidence angle */
  b_weight=1;     /* slope weighting */
  nits=20;        /* SIR iterations */
  angle_ref=53.0; /* reference incidence angle (if used) */
  response_threshold=-8.0;  /* response pattern minimum threshold in dB */
  flatten=FALSE;     /* flatten antenna response to 1,0 if TRUE */
  median_flag=FALSE; /* include median filter in SIR processing if TRUE */

  /* write to meta file */
  fprintf(mout," A_initialization=%10.5f\n", a_init);  
  fprintf(mout," A_offset_value=%10.5f\n", a_offset);
  fprintf(mout," B_initialization=%10.5f\n", b_init);
  fprintf(mout," B_weight=%10.5f\n", b_weight);
  fprintf(mout," Max_iterations=%3d\n", nits);
  fprintf(mout," Reference_incidence_angle=%10.5f\n", angle_ref);
  fprintf(mout," Response_threshold=%10.5f\n", response_threshold);
  fprintf(mout," Flat_response=%c\n", TF[flatten]);
  fprintf(mout," Median_filter=%c\n", TF[median_flag]);

  /* read region parameters definition file name */
  (void) get_prompt_sarg(argc,argn,argv,"Enter region parameters file name: (NONE for manual input)","NONE",rfile, sizeof(rfile));
  printf("rfile=%s  %d\n",rfile,strncmp(rfile,"NONE",4));  
 
  pfile=TRUE;
  fprintf(mout," Region_parameters_file=%s\n",rfile);
  pid=fopen(rfile,"r");
  if (pid==NULL) {
    fprintf(stderr,"*** could not open region parameters file: %s\n",rfile);
    exit(-1);      
  }
  fscanf(pid,"%d",&nregions);
  printf("Number of regions: %d\n",nregions);

  sections=FALSE;
  fprintf(mout," Num_Regions=%2d\n",nregions);
  
  /* for each region, read in the parameters that define the region 
     size and projection and data selection criteria */

  ircnt=0;  /* count total regions */
  for (iregion=0; iregion<nregions; iregion++) {
    dateline=FALSE;
    
    /* region ID number */ 

    fscanf(pid,"%d",&regnum);
    printf("Region %d number: %d\n",iregion,regnum);
    
    /* define region, using auto definition if possible */
    strncpy(regname,"Custom",10);
    if (regnum > 0) { /* use region definition from standard region definition file */
      getregdata(regnum,&iproj,&dateline,&latl,&lonl,&lath,&lonh,regname);
      if (((regnum >= 0) && (regnum < 100)) || (regnum >= 120)) poleflag=0; /* non-polar area */
      printf("Region name: '%s'  Def Proj %d  Dateline %d\n",regname,iproj,dateline);
    } else {
      printf(" Region is not defined and out of bounds " );
      exit(-1);
    }
    
    /* print region ID number and bounding box info */
    printf("\nRegion definition information\n");
    printf("  Latitude range:  %f %f\n",latl,lath);
    printf("  Longitude range: %f %f\n",lonl,lonh);
    printf("  Region polar code (0=arbitrary, 1=N pol, 2=S pole: %d\n",poleflag);
    if (dateline) {
      printf("  Region crosses dateline\n");
      maplxlon=min(lonh,lonl);
      maprxlon=max(lonh,lonl);
      lonl=maplxlon;
      lonh=maprxlon;
      printf("  Corrected longitude range: %f %f\n",lonl,lonh);
    }
     
    /* write region ID number and bound box info to meta file */
    fprintf(mout," Begin_region_description\n");
    fprintf(mout,"  Region_id=%4d\n", regnum);
    fprintf(mout,"  Latitude_low=%16.9f\n", latl);
    fprintf(mout,"  Latitude_high=%16.9f\n", lath);
    fprintf(mout,"  Longitude_low=%16.9f\n", lonl);
    fprintf(mout,"  Longitude_high=%16.9f\n", lonh);
    fprintf(mout,"  Dateline_crossing=%c\n", TF[dateline]);
    fprintf(mout,"  Polar_flag=%c\n", TF[poleflag]);
    fprintf(mout,"  Region_name=%s\n", regname);
    
    /* transformation information */

    /* projection */
    projt=iproj;  /* default value from region definition file */
    /* This version of meas_meta_make only does EASE2-N, -S, -T */
    if ( projt > 10 || projt < 8 ) {
      fprintf( stderr, "Only acceptable projections are 308, 309, 310, EASE2-N, -S, -T\n" );
      exit(-1);
    }
    /* projection codes 
       8 = EASE2 N
       9 = EASE2 S
      10 = EASE2 T */

    printf("Projection code ( 8=EASE2N,9=EASE2S,10=EASE2T ): %d\n",projt);

    /* define the origin, size, scale, offset for each projection */
    switch (projt) {

    case  8:  /* ease2 grid N */
    case  9:  /* ease2 grid S */
    case 10:  /* ease2 grid T */
      fscanf(pid,"%d",&nease);
      /* projt=regnum-300; */ 
      /* define projection parameters for particular EASE2 case */
      ind=0;  /* standard base resolution */
      printf("EASE2 parameters: proj=%d  nease=%d  ind=%d\n",projt,nease,ind);      
      ease2_map_info(projt, nease, ind, &map_equatorial_radius_m, 
		     &map_eccentricity, &e2,
		     &map_reference_latitude, &map_reference_longitude, 
		     &map_second_reference_latitude, &sin_phi1, &cos_phi1, &kz,
		     &map_scale, &bcols, &brows, &r0, &s0, &epsilon);

      nsx=bcols;             /* X dim (horizontal=cols) pixels */
      nsy=brows;             /* Y dim (vertical=rows) pixels */
      ascale=(float) nease;  /* base grid scale factor (0..5) */
      bscale=(float) ind;    /* base grid scale index (0..2) */
      a0=0.0;                /* X origin pixel - 1 */
      b0=0.0;                /* Y origin pixel - 1 */
      xdeg=(float) (nsx/2);  /* map center X pixel - 1 */
      ydeg=(float) (nsy/2);  /* map center Y pixel - 1 */
      xdim=xdeg*2;
      ydim=ydeg*2;
      aorglon=xdeg;
      aorglat=ydeg;
      break;

    default:
      fprintf(stderr,"*** Error selecting projection type %d ***\n", projt);
      exit(-1);      
    }
  
    /* select ascending/descending data */
    iasc=0;
    fscanf(pid,"%d",&iasc);
    printf("Asc/Desc flag: (0=both,1=asc,2=dsc,3=morn,4=eve) %d\n",iasc);
    fprintf(mout,"  AscDesc_flag=%2d\n",iasc);

    /* Selection is based on whichever platform is specified on the input */
    fscanf(pid,"%d",&ibeam);
    printf("Beam index (1=19H,2=19V,3=22V,4=37H,5=37V,6=85H,7=85V): %d\n",ibeam);
    ipolar=0;   /* h pol */
    if (ibeam==2 || ibeam==3 || ibeam==5 || ibeam==7) ipolar=1; /* v pol */
    fprintf(mout,"  Polarization=%d\n",ipolar);
    fprintf(mout,"  Beam_index=%d\n", ibeam);

    /* read number iterations from .def file */
    fscanf( pid, "%d", &nits );
    fprintf(mout," Max_iterations=%d\n", nits);

    /* summarize region results */
    if (projt != 0) {
      printf("Projection %d   size %d %d\n",projt,nsx,nsy);
      printf("Scales:           %f %f\n",ascale, bscale);
      printf("Origin (lat,lon)  %f %f\n",aorglat,aorglon);
      printf("Offset x,y in km: %f %f\n",a0,b0);
      printf("Dimensions in km: %f %f\n",xdim, ydim);
    }
    printf("size in pixels (x,y)(lon,lat): %f %f\n\n",nsx,nsy);

    /* set grid image size parameters */
    /* number of enhanced resolution pixels/non-enhanced pixels */
    /* for this project non-enhanced size is always 25 km grid */
    non_size=(1 << (nease) );
 
    if (non_size*(nsx/non_size) != nsx || non_size*(nsy/non_size) != nsy) {
      fprintf(stderr,"*** warning: non grid size parameter %d does not evenly divide image size: %d %d\n",non_size,nsx,nsy);
      fprintf(stdout,"*** warning: non grid size parameter %d does not evenly divide image size: %d %d\n",non_size,nsx,nsy);
    }

    /* optionally section region in to smaller images for processing.  They will be recombined later */
    nsection=0;
    printf("Sectioning code: %d\n",nsection);
    fprintf(mout,"  Sectioning_code=%d\n",nsection);
    if (nsection > 0) sections=TRUE;

  /* save unsectioned projection info */
    ascale_s=ascale;
    bscale_s=bscale;
    a0_s=a0;
    b0_s=b0;
    xdeg_s=xdeg;
    ydeg_s=ydeg;
    nsx_s=nsx;
    nsy_s=nsy;

    nsect=(nsection % 100);    /* number of sections */
    nt=nsection/100;           /* section type code */

    /* for each output section (0=unsection region) */
    for (isection=0; isection<=nsect; isection++) {
      fprintf(mout,"  Begin_section_description\n");
      fprintf(mout,"  Section_id=%d\n",isection);


      printf("\nSectioning: (x,y) %d %d\n",isection,nsect);

      /* write map projection info to output file */
      fprintf(mout,"   Project_type=%d\n",projt);
      fprintf(mout,"   Projection_origin_x=%16.9f\n", aorglat);
      fprintf(mout,"   Projection_origin_y=%16.9f\n", aorglon);
      fprintf(mout,"   Projection_offset_x=%16.9f\n", a0);
      fprintf(mout,"   Projection_offset_y=%16.9f\n", b0);
      fprintf(mout,"   Projection_scale_x=%16.9f\n", ascale);
      fprintf(mout,"   Projection_scale_y=%16.9f\n", bscale);
      fprintf(mout,"   Projection_dim_x=%d\n",xdim);
      fprintf(mout,"   Projection_dim_y=%d\n",ydim);
      fprintf(mout,"   Image_size_x=%d\n", nsx);
      fprintf(mout,"   Image_size_y=%d\n", nsy);

      /* generate parameters for non-enhanced gridded images */
      nsx2=nsx/non_size;
      nsy2=nsy/non_size;
      if (non_size*nsx2 != nsx || non_size*nsy2 != nsy)
	fprintf(stderr,"*** WARNING: non grid size %d ' does not evenly divide image size %d %d\n",non_size,nsx,nsy);
      ascale2=ascale;
      bscale2=bscale;
      if (projt==8 || projt==9 || projt==10) { /* EASE2 */
	ascale2=ascale-2;
      } else {
	nsx2=nsx;
	nsy2=nsy;
	fprintf(stderr,"*** WARNING: Projection type can not generate Non-enhanced parameters ***\n");
      }

      /* compute grid pixel locations */
      ix1g=(ix1-1)/non_size+1;
      iy1g=(iy1-1)/non_size+1;
      ix2g=(ix2-1)/non_size+1;
      iy2g=(iy2-1)/non_size+1;
      jx1g=(jx1-1)/non_size+1;
      jy1g=(jy1-1)/non_size+1;
      jx2g=(jx2-1)/non_size+1;
      jy2g=(jy2-1)/non_size+1;
    
      /* write grid projection info to meta file */

      fprintf(mout,"   Grid_scale_x=%d\n", non_size);
      fprintf(mout,"   Grid_scale_y=%d\n", non_size);
      fprintf(mout,"   Grid_size_x=%d\n", nsx2);
      fprintf(mout,"   Grid_size_y=%d\n", nsy2);
      fprintf(mout,"   Grid_projection_origin_x=%16.9f\n", aorglat);
      fprintf(mout,"   Grid_projection_origin_y=%16.9f\n", aorglon);
      fprintf(mout,"   Grid_projection_offset_x=%16.9f\n", a0);
      fprintf(mout,"   Grid_projection_offset_y=%16.9f\n", b0);
      fprintf(mout,"   Grid_projection_scale_x=%16.9f\n", ascale2);
      fprintf(mout,"   Grid_projection_scale_y=%16.9f\n", bscale2);
	      
      /* for this region, generate standard product data file names abreviation */
      switch(regnum) {
      case 308:
	strncpy(reg,"E2N",4);
	break;
      case 309:
	strncpy(reg,"E2S",4);
	break;
      case 310:
	strncpy(reg,"E2T",4);
	break;
      default:
	strncpy(reg,regname,3);
	reg[3]='\0';	
	break;	
      }
            
      /* write LTOD split time to file */
      /* note: tsplit values not 0 & 12 require more than one UTC as daily input */   
      if (iasc > 2) {
	/* northern hemisphere */
	tsplit1=0.0;
	tsplit2=12.0;
	/* southern hemisphere, use slightly different numbers */
	if ( regnum == 309 )  { /* E2S */
	  tsplit1=0.0;
	  tsplit2=12.0;
	}
	fprintf(mout,"   Local_time_split1=%16.9f\n", tsplit1);
	fprintf(mout,"   Local_time_split2=%16.9f\n", tsplit2);
      }
  
      /* create the full set of BYU naming standard file names -- whether used or not */
      iy=(year % 100);
      /* code for the correct names from cetb.h */
      if ( CETB_NIMBUS7 == F_num ) sen='R';
      if ( CETB_AQUA == F_num ) sen='A';
      if ( CETB_F08 <= F_num && F_num <= CETB_F13 ) sen='F';
      if ( CETB_F15 <= F_num && F_num < CETB_NUM_PLATFORMS ) sen='I';
      /* F=ssmi, A=AMSRE, R=SMMR, I=SSMIS */
      if (F_num < 10.0) /* code the sensor number based on cetb_platform_id*/
	cegg=(char) (F_num+48);  /* 0...9 */
      else
	cegg=(char) (F_num-10+65); /* A...Z */
      if ( ibeam < 10 )
	chan=(char) (ibeam+48);
      else
	chan=(char) (ibeam-10+97); // a...z
      cpol='b';  /* both asc and desc (all data) used */

      /* modify file name if LTOD ascending/descending or morn/even */

      if (iasc != 0) {
	cpol='a';  /* asc */
	if (iasc==2) cpol='d'; /* desc */
	if (iasc==3) cpol='m'; /* morning/midnight */
	if (iasc==4) cpol='e'; /* evening */
	if (iasc==5) cpol='n'; /* noon/night */
      }

     /* section names */
      sprintf(setname,"%c%c%c%c-%3s%0.2d-%0.3d-%0.3d.setup",sen,cegg,chan,cpol,reg,iy,dstart,dend);
      sprintf(lisname,"%c%c%c%c-%3s%0.2d-%0.3d-%0.3d.lis",sen,cegg,chan,cpol,reg,iy,dstart,dend);
      sprintf(a_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'a',reg,iy,dstart,dend,"sir");
      sprintf(b_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'b',reg,iy,dstart,dend,"sir");
      sprintf(i_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'I',reg,iy,dstart,dend,"sir");
      sprintf(j_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'J',reg,iy,dstart,dend,"sir");
      sprintf(c_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'C',reg,iy,dstart,dend,"sir");
      sprintf(p_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'p',reg,iy,dstart,dend,"sir");
      sprintf(v_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'V',reg,iy,dstart,dend,"sir");
      sprintf(e_name, "%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'E',reg,iy,dstart,dend,"sir");
      sprintf(aa_name,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'a',reg,iy,dstart,dend,"ave");
      sprintf(bb_name,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'b',reg,iy,dstart,dend,"ave");
      sprintf(non_aname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'a',reg,iy,dstart,dend,"non");
      sprintf(non_bname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'b',reg,iy,dstart,dend,"non");
      sprintf(non_vname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'V',reg,iy,dstart,dend,"non");
      sprintf(grd_aname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'a',reg,iy,dstart,dend,"grd");
      sprintf(grd_bname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'b',reg,iy,dstart,dend,"grd");
      sprintf(grd_vname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'V',reg,iy,dstart,dend,"grd");
      sprintf(grd_iname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'I',reg,iy,dstart,dend,"grd");
      sprintf(grd_jname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'J',reg,iy,dstart,dend,"grd");
      sprintf(grd_cname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'C',reg,iy,dstart,dend,"grd");
      sprintf(grd_pname,"%c%c%c%c-%c-%3s%0.2d-%0.3d-%0.3d.%3s",sen,cegg,chan,cpol,'p',reg,iy,dstart,dend,"grd");
      
      /* save *-a-*.sir, .ave names for job script */
      //name_store(iregion)=a_name;      
      //name_store2(iregion)=aa_name;
    
      /* write out product names to meta file */
    printf("Output setup file:%s\n",setname);
    printf("Output A file:    %s\n",a_name);
    //printf("Output B file:    %s\n",b_name(1:length(b_name)));
    printf("Output C file:    %s\n",c_name);
    printf("Output I file:    %s\n",i_name);
    printf("Output J file:    %s\n",j_name);
    printf("Output P file:    %s\n",p_name);
    printf("Output E file:    %s\n",e_name);
    printf("Output V file:    %s\n",v_name);
    printf("Output A ave file:%s\n",aa_name);
      //printf("Output B ave file:%s\n",bb_name);
    printf("Output A non file:%s\n",non_aname);
      //printf("Output B non file:%s\n",non_bname);
    printf("Output V non file:%s\n",non_vname);
    printf("Output A grd file:%s\n",grd_aname);
      //printf("Output B grd file:%s\n",grd_bname);
    printf("Output V grd file:%s\n",grd_vname);
    printf("Output I grd file:%s\n",grd_iname);
    printf("Output J grd file:%s\n",grd_jname);
    printf("Output C grd file:%s\n",grd_cname);
    printf("Output P grd file:%s\n",grd_pname);
    printf("Output lis file:  %s\n",lisname);

    fprintf(mout,"  Setup_file=%s\n",setname);
    fprintf(mout,"  Begin_product_file_names\n");
    fprintf(mout,"   SIRF_A_file=%s\n",a_name);
      //fprintf(mout,"   SIRF_B_file=%s\n",b_name);
    fprintf(mout,"   SIRF_C_file=%s\n",c_name);
    fprintf(mout,"   SIRF_I_file=%s\n",i_name);
    fprintf(mout,"   SIRF_J_file=%s\n",j_name);
    fprintf(mout,"   SIRF_E_file=%s\n",e_name);
    fprintf(mout,"   SIRF_V_file=%s\n",v_name);
    fprintf(mout,"   SIRF_P_file=%s\n",p_name);
    fprintf(mout,"   AVE_A_file=%s\n",aa_name);
      //fprintf(mout,"   AVE_B_file=%s\n",bb_name);
    fprintf(mout,"   GRD_A_file=%s\n",grd_aname);
      //fprintf(mout,"   GRD_B_file=%s\n",grd_bname);
    fprintf(mout,"   GRD_V_file=%s\n",grd_vname);
    fprintf(mout,"   GRD_I_file=%s\n",grd_iname);
    fprintf(mout,"   GRD_J_file=%s\n",grd_jname);
    fprintf(mout,"   GRD_C_file=%s\n",grd_cname);
    fprintf(mout,"   GRD_P_file=%s\n",grd_pname);
    fprintf(mout,"   NON_A_file=%s\n",non_aname);
      //fprintf(mout,"   NON_B_file=%s\n",non_bname);
    fprintf(mout,"   NON_V_file=%s\n",non_vname);
    fprintf(mout,"   Info_file=%s\n",lisname);
    fprintf(mout,"  End_product_file_names\n");

      /* add SIRF commands to job script */
    fprintf(mout," End_section_description\n");
    ircnt++;
    }
    /* end section loop */

    fprintf(mout," End_region_description\n");
  }      /* end region loop */
  fprintf(mout,"End_description\n");
  
  if (pfile) fclose(pid);
	      
  printf("\nTotal regional images: %d Regions: %d\n", ircnt,nregions);
  return(err);  

}


